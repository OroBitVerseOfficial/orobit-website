<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OroBitverse - Aplicación de Staking</title>
    <!-- Favicon de OroBit -->
    <link rel="icon" href="../images/orobit_logo_1280x720.png" type="image/png">
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts - Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Fondo oscuro */
            color: white;
            line-height: 1.6;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 2rem;
            background-color: #2d3748; /* Fondo ligeramente más claro para el contenido principal */
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
        }
        h1, h2, h3, h4, h5, h6 {
            font-weight: bold;
            color: #fbd38d; /* Color dorado para los títulos */
            margin-bottom: 1rem;
        }
        a {
            color: #63b3ed; /* Azul claro para enlaces */
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .tab-button {
            padding: 0.75rem 1.5rem;
            border-top-left-radius: 0.5rem;
            border-top-right-radius: 0.5rem;
            background-color: #4a5568;
            color: #cbd5e0;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        .tab-button.active {
            background-color: #2d3748;
            color: #fbd38d;
        }
        .tab-content {
            border-radius: 0.5rem;
            padding: 1.5rem;
            background-color: #2d3748;
        }
        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 500;
            color: #cbd5e0;
        }
        .form-input, .form-select {
            width: 100%;
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid #4a5568;
            background-color: #1a202c;
            color: white;
            outline: none;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .form-input:focus, .form-select:focus {
            border-color: #fbd38d;
            box-shadow: 0 0 0 3px rgba(251, 211, 141, 0.2);
        }
        .action-button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: all 0.2s ease;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .action-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .btn-primary {
            background-color: #fbd38d;
            color: #2d3748;
        }
        .btn-primary:hover:not(:disabled) {
            background-color: #fed7aa;
            transform: translateY(-1px);
        }
        .btn-secondary {
            background-color: #4a5568;
            color: white;
        }
        .btn-secondary:hover:not(:disabled) {
            background-color: #63708a;
            transform: translateY(-1px);
        }
        .message-box {
            background-color: #4a5568;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            word-wrap: break-word; /* Romper palabras largas */
            font-size: 0.9rem;
        }
        .message-box.error {
            background-color: #c53030;
        }
        .message-box.success {
            background-color: #38a169;
        }
        .dashboard-card {
            background-color: #4a5568;
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
        }
        .status-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        .status-badge.active { background-color: #38a169; } /* Verde para activo */
        .status-badge.withdrawn { background-color: #c53030; } /* Rojo para retirado */

        /* Estilos para el encabezado de la aplicación */
        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 2rem;
            background-color: rgba(26, 32, 44, 0.9); /* Fondo ligeramente transparente para el header */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            position: sticky;
            top: 0;
            z-index: 1000;
            margin-bottom: 2rem; /* Espacio para separar del contenido */
        }
        .app-header .logo-container {
            display: flex;
            align-items: center;
        }
        .app-header nav a {
            color: #fbd38d; /* Dorado para enlaces de navegación */
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease;
        }
        .app-header nav a:hover {
            background-color: #4a5568;
            text-decoration: none;
        }
        /* Estilos responsivos */
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
                margin: 0.5rem;
            }
            .app-header {
                flex-direction: column;
                padding: 1rem;
            }
            .app-header nav {
                margin-top: 1rem;
                display: flex;
                flex-wrap: wrap; /* Permite que los enlaces se envuelvan en pantallas pequeñas */
                justify-content: center;
            }
            .app-header nav a {
                margin: 0.25rem 0.5rem;
            }
        }
    </style>
</head>
<body class="bg-gray-900">
    <!-- Header de la Aplicación -->
    <header class="app-header">
        <div class="logo-container">
            <!-- El logo es un botón que lleva a la página de inicio -->
            <a href="../index.html" target="_blank" class="flex items-center">
                <img src="../images/orobit_logo_1280x720.png" alt="Logo de OroBit" class="h-10 rounded-full mr-3 shadow-lg">
                <span class="text-2xl font-bold text-yellow-400">OroBitverse</span>
            </a>
        </div>
        <nav>
            <!-- Enlaces de navegación a otras páginas del ecosistema -->
            <a href="../whitepaper.html" target="_blank">White Paper</a>
            <a href="../index.html" target="_blank">Inicio</a>
            <!-- Enlace al panel de administración -->
            <a href="../admin_panel.html" target="_blank">Panel Admin</a>
        </nav>
    </header>

    <div class="container mt-8">
        <h1 class="text-center mb-8">OroBitverse - Aplicación de Staking</h1>

        <!-- MetaMask Connection Status -->
        <div id="connectionStatus" class="message-box bg-blue-700 text-center mb-6">
            Conectando a MetaMask...
        </div>

        <div class="flex border-b border-gray-700 mb-4">
            <button id="stakeTabBtn" class="tab-button active">Stakear</button>
            <button id="dashboardTabBtn" class="tab-button">Mi Dashboard</button>
            <button id="withdrawTabBtn" class="tab-button">Retirar</button>
            <button id="adminTabBtn" class="tab-button hidden">Admin</button> <!-- Botón oculto por defecto -->
        </div>

        <!-- Contenido de la pestaña Stakear -->
        <div id="stakeContent" class="tab-content">
            <h2 class="text-2xl mb-4">Stakear OroBit</h2>
            <div class="mb-4">
                <label for="stakeAmount" class="form-label">Cantidad a Stakear (OroBit):</label>
                <input type="number" id="stakeAmount" class="form-input" placeholder="Ej. 1000" min="0" step="1">
            </div>
            <div class="mb-4">
                <label for="poolSelect" class="form-label">Selecciona un Pool de Staking:</label>
                <select id="poolSelect" class="form-select">
                    <!-- Opciones de pools se cargarán aquí dinámicamente -->
                </select>
            </div>
            <div class="mb-6">
                <p class="text-sm text-gray-400">APR del Pool Seleccionado: <span id="selectedPoolApr">--</span>%</p>
                <p class="text-sm text-gray-400">Duración del Pool Seleccionado: <span id="selectedPoolDuration">--</span></p>
            </div>
            <div class="flex space-x-4">
                <button id="approveButton" class="action-button btn-secondary flex-grow">Aprobar OroBit</button>
                <button id="stakeButton" class="action-button btn-primary flex-grow">Stakear OroBit</button>
            </div>
            <div id="stakeMessage" class="message-box hidden"></div>
        </div>

        <!-- Contenido de la pestaña Mi Dashboard -->
        <div id="dashboardContent" class="tab-content hidden">
            <h2 class="text-2xl mb-4">Mi Dashboard de Staking</h2>
            <p class="mb-4 text-gray-300">
                Cuenta Conectada: <span id="currentAccountDisplay" class="font-semibold break-all text-yellow-300"></span>
            </p>
            <p class="mb-6 text-gray-300">
                Balance de OroBit: <span id="userOroBitBalance" class="font-semibold text-yellow-300">Cargando...</span>
            </p>
            <div id="userStakesDisplay" class="dashboard-grid">
                <p class="col-span-full text-center text-gray-400">No hay stakes activos.</p>
            </div>
            <div id="dashboardMessage" class="message-box hidden"></div>
        </div>

        <!-- Contenido de la pestaña Retirar -->
        <div id="withdrawContent" class="tab-content hidden">
            <h2 class="text-2xl mb-4">Retirar Stake</h2>
            <div class="mb-4">
                <label for="withdrawStakeId" class="form-label">ID del Stake a Retirar:</label>
                <input type="number" id="withdrawStakeId" class="form-input" placeholder="Ej. 0" min="0" step="1">
            </div>
            <button id="withdrawButton" class="action-button btn-primary w-full">Retirar Stake</button>
            <div id="withdrawMessage" class="message-box hidden"></div>
        </div>

        <!-- Contenido de la pestaña Admin -->
        <div id="adminContent" class="tab-content hidden">
            <h2 class="text-2xl mb-4">Panel de Administración del Staking</h2>

            <!-- Sección Añadir Pool -->
            <div class="mb-6 p-4 border border-gray-600 rounded-lg">
                <h3 class="text-xl mb-3">Añadir Nuevo Pool de Staking</h3>
                <div class="mb-3">
                    <label for="newPoolDuration" class="form-label">Duración (segundos, 0 para flexible):</label>
                    <input type="number" id="newPoolDuration" class="form-input" placeholder="Ej. 2592000 (30 días)">
                </div>
                <div class="mb-3">
                    <label for="newPoolApr" class="form-label">APR (ej. 500 para 5%):</label>
                    <input type="number" id="newPoolApr" class="form-input" placeholder="Ej. 500">
                </div>
                <div class="mb-4 flex items-center">
                    <input type="checkbox" id="newPoolIsFlexible" class="mr-2">
                    <label for="newPoolIsFlexible" class="form-label m-0">Es Flexible</label>
                </div>
                <button id="addPoolButton" class="action-button btn-primary w-full">Añadir Pool</button>
                <div id="addPoolMessage" class="message-box hidden mt-2"></div>
            </div>

            <!-- Sección Actualizar Estado de Pool -->
            <div class="mb-6 p-4 border border-gray-600 rounded-lg">
                <h3 class="text-xl mb-3">Actualizar Estado de Pool</h3>
                <div class="mb-3">
                    <label for="updatePoolId" class="form-label">ID del Pool:</label>
                    <input type="number" id="updatePoolId" class="form-input" placeholder="Ej. 0">
                </div>
                <div class="mb-4 flex items-center">
                    <input type="checkbox" id="updatePoolIsActive" class="mr-2" checked>
                    <label for="updatePoolIsActive" class="form-label m-0">Activo</label>
                </div>
                <button id="updatePoolStatusButton" class="action-button btn-primary w-full">Actualizar Estado</button>
                <div id="updatePoolStatusMessage" class="message-box hidden mt-2"></div>
            </div>

            <!-- Sección Ajustar Penalización Retiro Anticipado -->
            <div class="mb-6 p-4 border border-gray-600 rounded-lg">
                <h3 class="text-xl mb-3">Ajustar Penalización Retiro Anticipado</h3>
                <div class="mb-3">
                    <label for="penaltyAmount" class="form-label">Penalización (puntos base, ej. 2000 para 20%):</label>
                    <input type="number" id="penaltyAmount" class="form-input" placeholder="Ej. 2000">
                </div>
                <button id="setPenaltyButton" class="action-button btn-primary w-full">Establecer Penalización</button>
                <div id="setPenaltyMessage" class="message-box hidden mt-2"></div>
            </div>

            <!-- Sección Establecer Bonus APR de Ballena -->
            <div class="mb-6 p-4 border border-gray-600 rounded-lg">
                <h3 class="text-xl mb-3">Establecer Bonus APR de Ballena</h3>
                <div class="mb-3">
                    <label for="whaleBonusApr" class="form-label">Bonus APR (puntos base, ej. 100 para 1%):</label>
                    <input type="number" id="whaleBonusApr" class="form-input" placeholder="Ej. 100">
                </div>
                <button id="setWhaleBonusAprButton" class="action-button btn-primary w-full">Establecer Bonus APR</button>
                <div id="setWhaleBonusAprMessage" class="message-box hidden mt-2"></div>
            </div>

            <!-- Sección Establecer Umbral de Ballena -->
            <div class="mb-6 p-4 border border-gray-600 rounded-lg">
                <h3 class="text-xl mb-3">Establecer Umbral de Ballena</h3>
                <div class="mb-3">
                    <label for="whaleThreshold" class="form-label">Umbral (cantidad de OroBit, ej. 500000):</label>
                    <input type="number" id="whaleThreshold" class="form-input" placeholder="Ej. 500000">
                </div>
                <button id="setWhaleThresholdButton" class="action-button btn-primary w-full">Establecer Umbral</button>
                <div id="setWhaleThresholdMessage" class="message-box hidden mt-2"></div>
            </div>

             <!-- Sección Depositar Recompensas -->
            <div class="mb-6 p-4 border border-gray-600 rounded-lg">
                <h3 class="text-xl mb-3">Depositar OroBit para Recompensas</h3>
                <p class="text-gray-400 text-sm mb-3">El balance actual del contrato es: <span id="contractBalanceDisplay" class="font-semibold">Cargando...</span> OroBit</p>
                <div class="mb-3">
                    <label for="depositAmount" class="form-label">Cantidad a Depositar:</label>
                    <input type="number" id="depositAmount" class="form-input" placeholder="Ej. 10000">
                </div>
                <button id="approveDepositButton" class="action-button btn-secondary w-full mb-2">Aprobar Depósito</button>
                <button id="depositRewardsButton" class="action-button btn-primary w-full">Depositar Recompensas</button>
                <div id="depositRewardsMessage" class="message-box hidden mt-2"></div>
            </div>

            <!-- Sección Retirar Tokens Accidentales -->
            <div class="mb-6 p-4 border border-gray-600 rounded-lg">
                <h3 class="text-xl mb-3">Retirar Tokens Accidentales</h3>
                <p class="text-gray-400 text-sm mb-3">¡CUIDADO! Esta función es para recuperar tokens ERC20 enviados por error, NO el token principal de staking (OroBit).</p>
                <div class="mb-3">
                    <label for="erc20TokenAddress" class="form-label">Dirección del Token ERC20:</label>
                    <input type="text" id="erc20TokenAddress" class="form-input" placeholder="Ej. 0x... (dirección del token)">
                </div>
                <div class="mb-3">
                    <label for="erc20WithdrawAmount" class="form-label">Cantidad a Retirar:</label>
                    <input type="number" id="erc20WithdrawAmount" class="form-input" placeholder="Ej. 100">
                </div>
                <button id="emergencyWithdrawButton" class="action-button btn-primary w-full bg-red-600 hover:bg-red-700">Retiro de Emergencia (Otro Token)</button>
                <div id="emergencyWithdrawMessage" class="message-box hidden mt-2"></div>
            </div>

            <div id="adminMessage" class="message-box hidden"></div>
        </div>
    </div>

    <!-- Web3.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/web3@1.7.0/dist/web3.min.js"></script>
    <script>
        // --- Configuraciones de la Blockchain ---
        // Direcciones de contratos en BNB Smart Chain Testnet
        const STAKING_CONTRACT_ADDRESS = "0x8278ebadbc25beea94d6370174b8eeb7b5bfd253"; // Contrato de Staking (OroBitStakingVault)
        const OROBIT_TOKEN_ADDRESS = "0x8bC4B9238047843C3Cb0508b9EdeB3a7729D72c3"; // Token OroBit
        
        const BNB_TESTNET_CHAIN_ID = '0x61'; // Chain ID para BNB Smart Chain Testnet (97 en decimal)
        const BNB_TESTNET_RPC_URL = 'https://data-seed-prebsc-1-s1.binance.org:8545/'; // RPC URL de la testnet
        
        // Cartera del propietario del contrato de staking (debe coincidir con el constructor del contrato)
        const OWNER_WALLET_ADDRESS = "0x0C6DA70B1BB307D78d154ec6adbD57ff696E0660";

        // ABIs de los contratos (simplificados para las funciones necesarias)
        const STAKING_CONTRACT_ABI = [
            // Funciones de Propietario (Owner)
            { "inputs": [], "name": "owner", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" },
            { "inputs": [], "name": "pause", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
            { "inputs": [], "name": "unpause", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
            { "inputs": [{ "internalType": "uint256", "name": "_duration", "type": "uint256" }, { "internalType": "uint256", "name": "_aprBP", "type": "uint256" }, { "internalType": "bool", "name": "_isFlexible", "type": "bool" }], "name": "addPool", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
            { "inputs": [{ "internalType": "uint256", "name": "_poolId", "type": "uint256" }, { "internalType": "bool", "name": "_isActive", "type": "bool" }], "name": "setPoolStatus", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
            { "inputs": [{ "internalType": "uint256", "name": "_newAPR_BP", "type": "uint256" }], "name": "setWhaleBonusAPR", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
            { "inputs": [{ "internalType": "uint256", "name": "_newThreshold", "type": "uint256" }], "name": "setWhaleThreshold", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
            { "inputs": [{ "internalType": "uint256", "name": "_newPenaltyBP", "type": "uint256" }], "name": "setEarlyWithdrawPenalty", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
            { "inputs": [{ "internalType": "address", "name": "_newAdminWallet", "type": "address" }], "name": "setStakingAdminWallet", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
            { "inputs": [{ "internalType": "uint256", "name": "_amount", "type": "uint256" }], "name": "depositRewards", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
            { "inputs": [{ "internalType": "address", "name": "_tokenAddress", "type": "address" }, { "internalType": "uint256", "name": "_amount", "type": "uint256" }], "name": "emergencyWithdrawToken", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
            { "inputs": [], "name": "paused", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" },
            { "inputs": [], "name": "earlyWithdrawPenaltyBP", "outputs": [{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            { "inputs": [], "name": "whaleBonusAPR_BP", "outputs": [{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            { "inputs": [], "name": "whaleThreshold", "outputs": [{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"stakingAdminWallet","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},
            {"inputs":[],"name":"getContractTokenBalance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},

            // Funciones de Usuario
            { "inputs": [{ "internalType": "uint256", "name": "_poolId", "type": "uint256" }, { "internalType": "uint256", "name": "_amount", "type": "uint256" }], "name": "stake", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
            { "inputs": [{ "internalType": "address", "name": "_user", "type": "address" }, { "internalType": "uint256", "name": "_stakeId", "type": "uint256" }], "name": "calculateReward", "outputs": [{ "internalType": "uint256", "name": "reward", "type": "uint256" }], "stateMutability": "view", "type": "function" },
            { "inputs": [{ "internalType": "uint256", "name": "_stakeId", "type": "uint256" }], "name": "withdraw", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
            { "inputs": [{ "internalType": "address", "name": "_user", "type": "address" }], "name": "getUserStakesLength", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" },
            { "inputs": [{ "internalType": "address", "name": "_user", "type": "address" }, { "internalType": "uint256", "name": "_stakeId", "type": "uint256" }], "name": "getUserStake", "outputs": [{ "internalType": "uint256", "name": "amount", "type": "uint256" }, { "internalType": "uint256", "name": "startTime", "type": "uint256" }, { "internalType": "uint256", "name": "duration", "type": "uint256" }, { "internalType": "uint256", "name": "aprBP", "type": "uint256" }, { "internalType": "bool", "name": "withdrawn", "type": "bool" }, { "internalType": "uint256", "name": "lastRewardClaimTime", "type": "uint256" }], "stateMutability": "view", "type": "function" },
            { "inputs": [{ "internalType": "uint256", "name": "_poolId", "type": "uint256" }], "name": "getPool", "outputs": [{ "internalType": "uint256", "name": "duration", "type": "uint256" }, { "internalType": "uint256", "name": "aprBP", "type": "uint256" }, { "internalType": "bool", "name": "isActive", "type": "bool" }, { "internalType": "bool", "name": "isFlexible", "type": "bool" }], "stateMutability": "view", "type": "function" },
            { "inputs": [], "name": "getStakingPoolsLength", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }
        ];

        const OROBIT_TOKEN_ABI = [
            { "inputs": [{ "internalType": "address", "name": "account", "type": "address" }], "name": "balanceOf", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" },
            { "inputs": [{ "internalType": "address", "name": "spender", "type": "address" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }], "name": "approve", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" },
            { "inputs": [{ "internalType": "address", "name": "owner", "type": "address" }, { "internalType": "address", "name": "spender", "type": "address" }], "name": "allowance", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }
        ];

        // --- Variables Globales ---
        let web3;
        let accounts;
        let currentAccount;
        let stakingContract;
        let oroBitTokenContract;
        let isOwner = false;
        let selectedPoolId = null;

        // --- Referencias a Elementos del DOM ---
        const connectionStatus = document.getElementById('connectionStatus');
        
        // Tabs
        const stakeTabBtn = document.getElementById('stakeTabBtn');
        const dashboardTabBtn = document.getElementById('dashboardTabBtn');
        const withdrawTabBtn = document.getElementById('withdrawTabBtn');
        const adminTabBtn = document.getElementById('adminTabBtn');

        const stakeContent = document.getElementById('stakeContent');
        const dashboardContent = document.getElementById('dashboardContent');
        const withdrawContent = document.getElementById('withdrawContent');
        const adminContent = document.getElementById('adminContent');

        // Stake Tab Elements
        const stakeAmountInput = document.getElementById('stakeAmount');
        const poolSelect = document.getElementById('poolSelect');
        const selectedPoolApr = document.getElementById('selectedPoolApr');
        const selectedPoolDuration = document.getElementById('selectedPoolDuration');
        const approveButton = document.getElementById('approveButton');
        const stakeButton = document.getElementById('stakeButton');
        const stakeMessage = document.getElementById('stakeMessage');

        // Dashboard Tab Elements
        const currentAccountDisplay = document.getElementById('currentAccountDisplay');
        const userOroBitBalance = document.getElementById('userOroBitBalance');
        const userStakesDisplay = document.getElementById('userStakesDisplay');
        const dashboardMessage = document.getElementById('dashboardMessage');

        // Withdraw Tab Elements
        const withdrawStakeIdInput = document.getElementById('withdrawStakeId');
        const withdrawButton = document.getElementById('withdrawButton');
        const withdrawMessage = document.getElementById('withdrawMessage');

        // Admin Tab Elements
        const newPoolDurationInput = document.getElementById('newPoolDuration');
        const newPoolAprInput = document.getElementById('newPoolApr');
        const newPoolIsFlexibleCheckbox = document.getElementById('newPoolIsFlexible');
        const addPoolButton = document.getElementById('addPoolButton');
        const addPoolMessage = document.getElementById('addPoolMessage');

        const updatePoolIdInput = document.getElementById('updatePoolId');
        const updatePoolIsActiveCheckbox = document.getElementById('updatePoolIsActive');
        const updatePoolStatusButton = document.getElementById('updatePoolStatusButton');
        const updatePoolStatusMessage = document.getElementById('updatePoolStatusMessage');

        const penaltyAmountInput = document.getElementById('penaltyAmount');
        const setPenaltyButton = document.getElementById('setPenaltyButton');
        const setPenaltyMessage = document.getElementById('setPenaltyMessage');

        const whaleBonusAprInput = document.getElementById('whaleBonusApr');
        const setWhaleBonusAprButton = document.getElementById('setWhaleBonusAprButton');
        const setWhaleBonusAprMessage = document.getElementById('setWhaleBonusAprMessage');

        const whaleThresholdInput = document.getElementById('whaleThreshold');
        const setWhaleThresholdButton = document.getElementById('setWhaleThresholdButton');
        const setWhaleThresholdMessage = document.getElementById('setWhaleThresholdMessage');

        const depositAmountInput = document.getElementById('depositAmount');
        const approveDepositButton = document.getElementById('approveDepositButton');
        const depositRewardsButton = document.getElementById('depositRewardsButton');
        const depositRewardsMessage = document.getElementById('depositRewardsMessage');
        const contractBalanceDisplay = document.getElementById('contractBalanceDisplay');

        const erc20TokenAddressInput = document.getElementById('erc20TokenAddress');
        const erc20WithdrawAmountInput = document.getElementById('erc20WithdrawAmount');
        const emergencyWithdrawButton = document.getElementById('emergencyWithdrawButton');
        const emergencyWithdrawMessage = document.getElementById('emergencyWithdrawMessage');
        
        const adminMessage = document.getElementById('adminMessage');


        // --- Utilidades ---
        function showMessage(element, message, type = 'info') {
            element.textContent = message;
            element.className = `message-box mt-2 ${type}`;
            element.classList.remove('hidden');
        }

        function hideMessage(element) {
            element.classList.add('hidden');
            element.textContent = '';
        }

        function formatEther(amountWei) {
            if (!web3) return 'N/A';
            return parseFloat(web3.utils.fromWei(amountWei, 'ether')).toFixed(4);
        }

        function toWei(amountEther) {
            if (!web3) return '0';
            return web3.utils.toWei(amountEther, 'ether');
        }

        // Función para decodificar mensajes de revert (simplificada)
        function decodeRevertReason(hexString) {
            if (!hexString || hexString.length < 10) return "Razón de revert desconocida";
            if (hexString.startsWith('0x08c379a0')) { // Selector de error para Solidity's `Error(string)`
                try {
                    const dataPart = hexString.substring(10);
                    let decoded = '';
                    for (let i = 0; i < dataPart.length; i += 2) {
                        decoded += String.fromCharCode(parseInt(dataPart.substr(i, 2), 16));
                    }
                    decoded = decoded.replace(/[^ -~]+/g, ''); // Limpiar caracteres no ASCII
                    if (decoded.length > 0) return `Revert: "${decoded.trim()}"`;
                } catch (e) {
                    console.warn("Error decodificando razón de revert:", e);
                }
            }
            return "Revert: Sin mensaje de error claro.";
        }

        // --- Funciones de Conexión a MetaMask y Red ---
        async function connectWallet() {
            console.log("Intentando conectar a MetaMask...");
            if (typeof window.ethereum === 'undefined' || !window.ethereum) {
                showMessage(connectionStatus, 'MetaMask no detectado. Por favor, instale MetaMask.', 'error');
                return;
            }

            // Manejar múltiples proveedores (si aplica, priorizar MetaMask)
            if (window.ethereum.providers && window.ethereum.providers.length > 1) {
                const metamaskProvider = window.ethereum.providers.find((provider) => provider.isMetaMask);
                if (metamaskProvider) {
                    window.ethereum = metamaskProvider;
                    console.log("Múltiples proveedores detectados, priorizando MetaMask.");
                } else {
                    showMessage(connectionStatus, 'Error: Billeteras en conflicto. Deshabilite otras extensiones de billetera.', 'error');
                    return;
                }
            }

            try {
                web3 = new Web3(window.ethereum);
                accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                if (accounts.length === 0) {
                    showMessage(connectionStatus, 'Ninguna cuenta conectada. Conecte una cuenta en MetaMask.', 'error');
                    return;
                }
                currentAccount = accounts[0];
                console.log("Cuenta conectada:", currentAccount);
                currentAccountDisplay.textContent = currentAccount;

                // Verificar y cambiar la red si es necesario
                const chainId = await web3.eth.getChainId();
                if (chainId !== parseInt(BNB_TESTNET_CHAIN_ID, 16)) {
                    console.log("Red incorrecta. Intentando cambiar a BNB Testnet.");
                    try {
                        await window.ethereum.request({
                            method: 'wallet_switchEthereumChain',
                            params: [{ chainId: BNB_TESTNET_CHAIN_ID }],
                        });
                        showMessage(connectionStatus, 'Conectado a MetaMask (Red BNB Testnet)', 'success');
                    } catch (switchError) {
                        if (switchError.code === 4902) { // La red no ha sido añadida en MetaMask
                            console.log("Red no añadida. Intentando añadirla.");
                            try {
                                await window.ethereum.request({
                                    method: 'wallet_addEthereumChain',
                                    params: [{
                                        chainId: BNB_TESTNET_CHAIN_ID,
                                        chainName: 'BNB Smart Chain Testnet',
                                        rpcUrls: [BNB_TESTNET_RPC_URL],
                                        nativeCurrency: { name: 'BNB', symbol: 'tBNB', decimals: 18 },
                                        blockExplorerUrls: ['https://testnet.bscscan.com/'],
                                    }],
                                });
                                showMessage(connectionStatus, 'Conectado a MetaMask (Red BNB Testnet Añadida)', 'success');
                            } catch (addError) {
                                console.error('Error al añadir la red:', addError);
                                showMessage(connectionStatus, `Error al añadir BNB Testnet: ${addError.message}`, 'error');
                                return;
                            }
                        } else {
                            console.error('Error al cambiar la red:', switchError);
                            showMessage(connectionStatus, `Error al cambiar a BNB Testnet: ${switchError.message}`, 'error');
                            return;
                        }
                    }
                } else {
                    showMessage(connectionStatus, 'Conectado a MetaMask (Red BNB Testnet)', 'success');
                }

                // Inicializar instancias de contratos
                stakingContract = new web3.eth.Contract(STAKING_CONTRACT_ABI, STAKING_CONTRACT_ADDRESS);
                oroBitTokenContract = new web3.eth.Contract(OROBIT_TOKEN_ABI, OROBIT_TOKEN_ADDRESS);

                // Verificar si la cuenta conectada es el propietario para mostrar el panel de administración
                const ownerAddress = await stakingContract.methods.owner().call();
                isOwner = (currentAccount.toLowerCase() === ownerAddress.toLowerCase());
                if (isOwner) {
                    adminTabBtn.classList.remove('hidden');
                    showMessage(connectionStatus, 'Conectado a MetaMask (Propietario)', 'success');
                } else {
                    adminTabBtn.classList.add('hidden');
                }

                // Cargar datos iniciales
                await loadPools();
                await updateDashboard();
                if (isOwner) {
                    await loadAdminData(); // Cargar datos para el panel de administración
                }

            } catch (error) {
                console.error("Error al conectar la billetera:", error);
                showMessage(connectionStatus, `Error al conectar MetaMask: ${error.message || error}`, 'error');
            }
        }

        // --- Manejo de Eventos de MetaMask ---
        if (window.ethereum) {
            window.ethereum.on('accountsChanged', (newAccounts) => {
                console.log("Cuentas cambiadas:", newAccounts);
                if (newAccounts.length > 0) {
                    currentAccount = newAccounts[0];
                    connectWallet(); // Re-conectar para actualizar la UI
                } else {
                    currentAccount = null;
                    stakingContract = null;
                    oroBitTokenContract = null;
                    isOwner = false;
                    adminTabBtn.classList.add('hidden');
                    showMessage(connectionStatus, 'MetaMask desconectado. Por favor, conecte una cuenta.', 'error');
                    // Limpiar dashboard y otros datos
                    userOroBitBalance.textContent = 'N/A';
                    userStakesDisplay.innerHTML = '<p class="col-span-full text-center text-gray-400">MetaMask desconectado. Conecte su billetera para ver sus stakes.</p>';
                    currentAccountDisplay.textContent = 'No conectado';
                }
            });

            window.ethereum.on('chainChanged', (chainId) => {
                console.log("Red cambiada a:", chainId);
                connectWallet(); // Re-conectar para asegurar la red correcta y recargar datos
            });
        }

        // --- Lógica de Pestañas (Tabs) ---
        function showTab(tabId) {
            // Ocultar todos los contenidos de las pestañas
            stakeContent.classList.add('hidden');
            dashboardContent.classList.add('hidden');
            withdrawContent.classList.add('hidden');
            adminContent.classList.add('hidden');

            // Desactivar todos los botones de pestañas
            stakeTabBtn.classList.remove('active');
            dashboardTabBtn.classList.remove('active');
            withdrawTabBtn.classList.remove('active');
            adminTabBtn.classList.remove('active');

            // Mostrar el contenido de la pestaña seleccionada
            document.getElementById(tabId + 'Content').classList.remove('hidden');
            // Activar el botón de la pestaña seleccionada
            document.getElementById(tabId + 'TabBtn').classList.add('active');

            // Cargar datos específicos si la pestaña lo requiere
            if (tabId === 'dashboard') {
                updateDashboard();
            } else if (tabId === 'stake') {
                loadPools();
            } else if (tabId === 'admin' && isOwner) {
                loadAdminData();
            }
        }

        stakeTabBtn.addEventListener('click', () => showTab('stake'));
        dashboardTabBtn.addEventListener('click', () => showTab('dashboard'));
        withdrawTabBtn.addEventListener('click', () => showTab('withdraw'));
        adminTabBtn.addEventListener('click', () => showTab('admin'));

        // --- Funciones de Carga de Datos ---
        async function loadPools() {
            if (!stakingContract) {
                console.warn("Contrato de Staking no inicializado.");
                return;
            }
            try {
                const poolsLength = await stakingContract.methods.getStakingPoolsLength().call();
                poolSelect.innerHTML = ''; // Limpiar opciones existentes

                for (let i = 0; i < poolsLength; i++) {
                    const pool = await stakingContract.methods.getPool(i).call();
                    if (pool.isActive) {
                        const option = document.createElement('option');
                        option.value = i; // Guardar el ID del pool
                        const durationText = pool.isFlexible ? "Flexible" : `${pool.duration / (24 * 60 * 60)} días`;
                        option.textContent = `Pool ID ${i}: APR ${pool.aprBP / 100}% - Duración: ${durationText}`;
                        poolSelect.appendChild(option);
                    }
                }
                // Seleccionar el primer pool por defecto y actualizar sus detalles
                if (poolSelect.options.length > 0) {
                    selectedPoolId = parseInt(poolSelect.value);
                    updateSelectedPoolDetails();
                } else {
                    selectedPoolApr.textContent = '--';
                    selectedPoolDuration.textContent = '--';
                }
            } catch (error) {
                console.error("Error al cargar pools:", error);
                showMessage(stakeMessage, `Error al cargar pools: ${error.message || error}`, 'error');
            }
        }

        async function updateSelectedPoolDetails() {
            if (selectedPoolId !== null && stakingContract) {
                try {
                    const pool = await stakingContract.methods.getPool(selectedPoolId).call();
                    selectedPoolApr.textContent = (pool.aprBP / 100).toFixed(2);
                    selectedPoolDuration.textContent = pool.isFlexible ? "Flexible" : `${pool.duration / (24 * 60 * 60)} días`;
                } catch (error) {
                    console.error("Error al actualizar detalles del pool:", error);
                    selectedPoolApr.textContent = '--';
                    selectedPoolDuration.textContent = '--';
                }
            }
        }

        poolSelect.addEventListener('change', (event) => {
            selectedPoolId = parseInt(event.target.value);
            updateSelectedPoolDetails();
        });


        async function updateDashboard() {
            if (!web3 || !currentAccount || !oroBitTokenContract || !stakingContract) {
                userOroBitBalance.textContent = 'Conecte MetaMask';
                userStakesDisplay.innerHTML = '<p class="col-span-full text-center text-gray-400">Conecte su billetera para ver sus stakes.</p>';
                return;
            }

            hideMessage(dashboardMessage);
            userOroBitBalance.textContent = 'Cargando...';
            userStakesDisplay.innerHTML = '<p class="col-span-full text-center text-gray-400">Cargando stakes...</p>';

            try {
                // Obtener balance de OroBit del usuario
                const balanceWei = await oroBitTokenContract.methods.balanceOf(currentAccount).call();
                userOroBitBalance.textContent = `${formatEther(balanceWei)} OROBIT`;

                // Obtener stakes del usuario
                const stakesLength = await stakingContract.methods.getUserStakesLength(currentAccount).call();
                userStakesDisplay.innerHTML = ''; // Limpiar stakes existentes

                if (stakesLength === 0) {
                    userStakesDisplay.innerHTML = '<p class="col-span-full text-center text-gray-400">No tienes stakes activos.</p>';
                } else {
                    for (let i = 0; i < stakesLength; i++) {
                        const stake = await stakingContract.methods.getUserStake(currentAccount, i).call();
                        
                        // Solo mostrar stakes no retirados para mantener el dashboard limpio
                        if (!stake.withdrawn) {
                            const reward = await stakingContract.methods.calculateReward(currentAccount, i).call();
                            const startTime = new Date(parseInt(stake.startTime) * 1000);
                            const endTime = new Date((parseInt(stake.startTime) + parseInt(stake.duration)) * 1000);
                            const now = new Date();

                            let statusText = "Activo";
                            let statusClass = "active";
                            if (stake.withdrawn) {
                                statusText = "Retirado";
                                statusClass = "withdrawn";
                            } else if (stake.duration > 0 && now > endTime) {
                                statusText = "Terminado"; // Fijo y ya pasó el tiempo
                                statusClass = "active"; // Sigue siendo "activo" en el sentido de que se puede retirar
                            } else if (stake.duration === 0) {
                                statusText = "Flexible";
                                statusClass = "active";
                            }
                            
                            const stakeCard = `
                                <div class="dashboard-card">
                                    <h3 class="text-xl font-semibold mb-2">Stake ID: ${i} <span class="status-badge ${statusClass}">${statusText}</span></h3>
                                    <p><strong>Cantidad:</strong> ${formatEther(stake.amount)} OROBIT</p>
                                    <p><strong>APR:</strong> ${stake.aprBP / 100}%</p>
                                    <p><strong>Inicio:</strong> ${startTime.toLocaleString()}</p>
                                    <p><strong>Duración:</strong> ${stake.duration === '0' ? 'Flexible' : `${stake.duration / (24 * 60 * 60)} días`}</p>
                                    <p><strong>Fin:</strong> ${stake.duration === '0' ? 'N/A' : endTime.toLocaleString()}</p>
                                    <p><strong>Recompensa Acumulada:</strong> <span class="text-green-400">${formatEther(reward)} OROBIT</span></p>
                                </div>
                            `;
                            userStakesDisplay.innerHTML += stakeCard;
                        }
                    }
                    if (userStakesDisplay.innerHTML === '') {
                        userStakesDisplay.innerHTML = '<p class="col-span-full text-center text-gray-400">No tienes stakes activos.</p>';
                    }
                }
            } catch (error) {
                console.error("Error al actualizar el dashboard:", error);
                showMessage(dashboardMessage, `Error al cargar dashboard: ${error.message || error}`, 'error');
            }
        }

        async function loadAdminData() {
            if (!stakingContract || !isOwner) {
                showMessage(adminMessage, 'Acceso denegado. Solo el propietario puede ver este panel.', 'error');
                adminContent.classList.add('hidden'); // Asegurarse de que el contenido esté oculto
                adminTabBtn.classList.add('hidden'); // Asegurarse de que el botón esté oculto
                return;
            }
            hideMessage(adminMessage);

            try {
                // Cargar valores actuales de la configuración del contrato
                const penalty = await stakingContract.methods.earlyWithdrawPenaltyBP().call();
                penaltyAmountInput.value = penalty;

                const whaleApr = await stakingContract.methods.whaleBonusAPR_BP().call();
                whaleBonusAprInput.value = whaleApr;

                const whaleThresh = await stakingContract.methods.whaleThreshold().call();
                whaleThresholdInput.value = formatEther(whaleThresh); // Convertir de wei a ether para mostrar

                // Cargar balance de tokens del contrato
                const contractBalance = await stakingContract.methods.getContractTokenBalance().call();
                contractBalanceDisplay.textContent = formatEther(contractBalance);

            } catch (error) {
                console.error("Error al cargar datos del administrador:", error);
                showMessage(adminMessage, `Error al cargar datos del admin: ${error.message || error}`, 'error');
            }
        }

        // --- Funciones de Interacción con el Contrato ---
        async function handleApprove() {
            if (!web3 || !currentAccount || !oroBitTokenContract || !stakingContract) {
                showMessage(stakeMessage, 'Por favor, conecte su billetera MetaMask primero.', 'error');
                return;
            }

            hideMessage(stakeMessage);
            const amount = stakeAmountInput.value;
            if (amount <= 0) {
                showMessage(stakeMessage, 'Por favor, introduzca una cantidad válida para aprobar.', 'error');
                return;
            }

            try {
                // Aprobar una cantidad muy grande para evitar tener que aprobar varias veces
                const amountToApprove = web3.utils.toWei(amount.toString(), 'ether'); // Convertir a Wei
                
                showMessage(stakeMessage, 'Enviando transacción de aprobación... Por favor, confirme en MetaMask.', 'info');
                const tx = await oroBitTokenContract.methods.approve(STAKING_CONTRACT_ADDRESS, amountToApprove).send({ from: currentAccount });
                
                showMessage(stakeMessage, `Aprobación exitosa. Hash de transacción: <a href="https://testnet.bscscan.com/tx/${tx.transactionHash}" target="_blank" class="text-blue-300 hover:underline">Ver Transacción</a>`, 'success');
                console.log("Transacción de aprobación:", tx);
            } catch (error) {
                const decodedError = decodeRevertReason(error.message);
                console.error("Error al aprobar:", error);
                showMessage(stakeMessage, `Error al aprobar: ${decodedError}`, 'error');
            }
        }

        async function handleStake() {
            if (!web3 || !currentAccount || !oroBitTokenContract || !stakingContract) {
                showMessage(stakeMessage, 'Por favor, conecte su billetera MetaMask primero.', 'error');
                return;
            }
            if (selectedPoolId === null) {
                showMessage(stakeMessage, 'Por favor, seleccione un pool de staking.', 'error');
                return;
            }

            hideMessage(stakeMessage);
            const amount = stakeAmountInput.value;
            if (amount <= 0) {
                showMessage(stakeMessage, 'Por favor, introduzca una cantidad válida para stakear.', 'error');
                return;
            }

            try {
                // Convertir la cantidad a Wei
                const amountInWei = web3.utils.toWei(amount.toString(), 'ether');

                // Verificar allowance antes de stakear
                const allowance = await oroBitTokenContract.methods.allowance(currentAccount, STAKING_CONTRACT_ADDRESS).call();
                if (BigInt(allowance) < BigInt(amountInWei)) {
                    showMessage(stakeMessage, 'Cantidad insuficiente aprobada para el contrato de staking. Por favor, apruebe primero.', 'error');
                    return;
                }

                // Verificar si el contrato está pausado
                const isPaused = await stakingContract.methods.paused().call();
                if (isPaused) {
                    showMessage(stakeMessage, 'El contrato de staking está actualmente pausado por el administrador. Inténtelo más tarde.', 'error');
                    return;
                }

                showMessage(stakeMessage, 'Enviando transacción de stake... Por favor, confirme en MetaMask.', 'info');
                const tx = await stakingContract.methods.stake(selectedPoolId, amountInWei).send({ from: currentAccount });
                
                showMessage(stakeMessage, `Stake exitoso. Hash de transacción: <a href="https://testnet.bscscan.com/tx/${tx.transactionHash}" target="_blank" class="text-blue-300 hover:underline">Ver Transacción</a>`, 'success');
                console.log("Transacción de stake:", tx);
                stakeAmountInput.value = ''; // Limpiar campo
                updateDashboard(); // Actualizar dashboard después del stake
            } catch (error) {
                const decodedError = decodeRevertReason(error.message);
                console.error("Error al stakear:", error);
                showMessage(stakeMessage, `Error al stakear: ${decodedError}`, 'error');
            }
        }

        async function handleWithdraw() {
            if (!web3 || !currentAccount || !stakingContract) {
                showMessage(withdrawMessage, 'Por favor, conecte su billetera MetaMask primero.', 'error');
                return;
            }

            hideMessage(withdrawMessage);
            const stakeId = withdrawStakeIdInput.value;
            if (stakeId === '' || parseInt(stakeId) < 0) {
                showMessage(withdrawMessage, 'Por favor, introduzca un ID de stake válido.', 'error');
                return;
            }

            try {
                // Verificar si el contrato está pausado
                const isPaused = await stakingContract.methods.paused().call();
                if (isPaused) {
                    showMessage(withdrawMessage, 'El contrato de staking está actualmente pausado por el administrador. No se pueden realizar retiros.', 'error');
                    return;
                }

                showMessage(withdrawMessage, 'Enviando transacción de retiro... Por favor, confirme en MetaMask.', 'info');
                const tx = await stakingContract.methods.withdraw(stakeId).send({ from: currentAccount });

                showMessage(withdrawMessage, `Retiro exitoso. Hash de transacción: <a href="https://testnet.bscscan.com/tx/${tx.transactionHash}" target="_blank" class="text-blue-300 hover:underline">Ver Transacción</a>`, 'success');
                console.log("Transacción de retiro:", tx);
                withdrawStakeIdInput.value = ''; // Limpiar campo
                updateDashboard(); // Actualizar dashboard después del retiro
            } catch (error) {
                const decodedError = decodeRevertReason(error.message);
                console.error("Error al retirar:", error);
                showMessage(withdrawMessage, `Error al retirar: ${decodedError}`, 'error');
            }
        }

        // --- Funciones de Administración ---
        async function handleAddPool() {
            if (!web3 || !currentAccount || !stakingContract || !isOwner) {
                showMessage(addPoolMessage, 'Acceso denegado. Solo el propietario puede añadir pools.', 'error');
                return;
            }
            hideMessage(addPoolMessage);

            const duration = newPoolDurationInput.value;
            const apr = newPoolAprInput.value;
            const isFlexible = newPoolIsFlexibleCheckbox.checked;

            if (duration === '' || apr === '') {
                showMessage(addPoolMessage, 'Por favor, complete todos los campos.', 'error');
                return;
            }
            if (parseInt(apr) <= 0) {
                showMessage(addPoolMessage, 'El APR debe ser mayor que 0.', 'error');
                return;
            }
            if (isFlexible && parseInt(duration) !== 0) {
                showMessage(addPoolMessage, 'Un pool flexible debe tener una duración de 0.', 'error');
                return;
            }
            if (!isFlexible && parseInt(duration) <= 0) {
                showMessage(addPoolMessage, 'Un pool fijo debe tener una duración mayor que 0.', 'error');
                return;
            }


            try {
                showMessage(addPoolMessage, 'Enviando transacción de añadir pool... Por favor, confirme en MetaMask.', 'info');
                const tx = await stakingContract.methods.addPool(duration, apr, isFlexible).send({ from: currentAccount });
                showMessage(addPoolMessage, `Pool añadido exitosamente. Hash: <a href="https://testnet.bscscan.com/tx/${tx.transactionHash}" target="_blank" class="text-blue-300 hover:underline">Ver Transacción</a>`, 'success');
                console.log("Pool añadido:", tx);
                newPoolDurationInput.value = '';
                newPoolAprInput.value = '';
                newPoolIsFlexibleCheckbox.checked = false;
                loadPools(); // Recargar la lista de pools en la pestaña de Stakear
            } catch (error) {
                const decodedError = decodeRevertReason(error.message);
                console.error("Error al añadir pool:", error);
                showMessage(addPoolMessage, `Error al añadir pool: ${decodedError}`, 'error');
            }
        }

        async function handleUpdatePoolStatus() {
            if (!web3 || !currentAccount || !stakingContract || !isOwner) {
                showMessage(updatePoolStatusMessage, 'Acceso denegado. Solo el propietario puede actualizar el estado de los pools.', 'error');
                return;
            }
            hideMessage(updatePoolStatusMessage);

            const poolId = updatePoolIdInput.value;
            const isActive = updatePoolIsActiveCheckbox.checked;

            if (poolId === '' || parseInt(poolId) < 0) {
                showMessage(updatePoolStatusMessage, 'Por favor, introduzca un ID de pool válido.', 'error');
                return;
            }

            try {
                showMessage(updatePoolStatusMessage, 'Enviando transacción de actualización de pool... Por favor, confirme en MetaMask.', 'info');
                const tx = await stakingContract.methods.setPoolStatus(poolId, isActive).send({ from: currentAccount });
                showMessage(updatePoolStatusMessage, `Estado del pool actualizado exitosamente. Hash: <a href="https://testnet.bscscan.com/tx/${tx.transactionHash}" target="_blank" class="text-blue-300 hover:underline">Ver Transacción</a>`, 'success');
                console.log("Estado del pool actualizado:", tx);
                loadPools(); // Recargar la lista de pools en la pestaña de Stakear
            } catch (error) {
                const decodedError = decodeRevertReason(error.message);
                console.error("Error al actualizar estado del pool:", error);
                showMessage(updatePoolStatusMessage, `Error al actualizar estado del pool: ${decodedError}`, 'error');
            }
        }

        async function handleSetPenalty() {
            if (!web3 || !currentAccount || !stakingContract || !isOwner) {
                showMessage(setPenaltyMessage, 'Acceso denegado. Solo el propietario puede ajustar la penalización.', 'error');
                return;
            }
            hideMessage(setPenaltyMessage);

            const penalty = penaltyAmountInput.value;
            if (penalty === '' || parseInt(penalty) < 0) {
                showMessage(setPenaltyMessage, 'Por favor, introduzca un valor de penalización válido (puntos base).', 'error');
                return;
            }

            try {
                showMessage(setPenaltyMessage, 'Enviando transacción de ajuste de penalización... Por favor, confirme en MetaMask.', 'info');
                const tx = await stakingContract.methods.setEarlyWithdrawPenalty(penalty).send({ from: currentAccount });
                showMessage(setPenaltyMessage, `Penalización ajustada exitosamente. Hash: <a href="https://testnet.bscscan.com/tx/${tx.transactionHash}" target="_blank" class="text-blue-300 hover:underline">Ver Transacción</a>`, 'success');
                console.log("Penalización ajustada:", tx);
            } catch (error) {
                const decodedError = decodeRevertReason(error.message);
                console.error("Error al ajustar penalización:", error);
                showMessage(setPenaltyMessage, `Error al ajustar penalización: ${decodedError}`, 'error');
            }
        }

        async function handleSetWhaleBonusApr() {
            if (!web3 || !currentAccount || !stakingContract || !isOwner) {
                showMessage(setWhaleBonusAprMessage, 'Acceso denegado. Solo el propietario puede ajustar el bonus de ballena.', 'error');
                return;
            }
            hideMessage(setWhaleBonusAprMessage);

            const bonusApr = whaleBonusAprInput.value;
            if (bonusApr === '' || parseInt(bonusApr) < 0) {
                showMessage(setWhaleBonusAprMessage, 'Por favor, introduzca un valor de APR de bonus válido (puntos base).', 'error');
                return;
            }

            try {
                showMessage(setWhaleBonusAprMessage, 'Enviando transacción de ajuste de bonus APR... Por favor, confirme en MetaMask.', 'info');
                const tx = await stakingContract.methods.setWhaleBonusAPR(bonusApr).send({ from: currentAccount });
                showMessage(setWhaleBonusAprMessage, `Bonus APR de ballena ajustado exitosamente. Hash: <a href="https://testnet.bscscan.com/tx/${tx.transactionHash}" target="_blank" class="text-blue-300 hover:underline">Ver Transacción</a>`, 'success');
                console.log("Bonus APR de ballena ajustado:", tx);
            } catch (error) {
                const decodedError = decodeRevertReason(error.message);
                console.error("Error al ajustar bonus APR de ballena:", error);
                showMessage(setWhaleBonusAprMessage, `Error al ajustar bonus APR de ballena: ${decodedError}`, 'error');
            }
        }

        async function handleSetWhaleThreshold() {
            if (!web3 || !currentAccount || !stakingContract || !isOwner) {
                showMessage(setWhaleThresholdMessage, 'Acceso denegado. Solo el propietario puede ajustar el umbral de ballena.', 'error');
                return;
            }
            hideMessage(setWhaleThresholdMessage);

            const threshold = whaleThresholdInput.value;
            if (threshold === '' || parseInt(threshold) <= 0) {
                showMessage(setWhaleThresholdMessage, 'Por favor, introduzca un umbral de ballena válido (cantidad de OroBit).', 'error');
                return;
            }

            try {
                const thresholdInWei = web3.utils.toWei(threshold.toString(), 'ether');
                showMessage(setWhaleThresholdMessage, 'Enviando transacción de ajuste de umbral de ballena... Por favor, confirme en MetaMask.', 'info');
                const tx = await stakingContract.methods.setWhaleThreshold(thresholdInWei).send({ from: currentAccount });
                showMessage(setWhaleThresholdMessage, `Umbral de ballena ajustado exitosamente. Hash: <a href="https://testnet.bscscan.com/tx/${tx.transactionHash}" target="_blank" class="text-blue-300 hover:underline">Ver Transacción</a>`, 'success');
                console.log("Umbral de ballena ajustado:", tx);
            } catch (error) {
                const decodedError = decodeRevertReason(error.message);
                console.error("Error al ajustar umbral de ballena:", error);
                showMessage(setWhaleThresholdMessage, `Error al ajustar umbral de ballena: ${decodedError}`, 'error');
            }
        }

        async function handleApproveDeposit() {
            if (!web3 || !currentAccount || !oroBitTokenContract || !isOwner) {
                showMessage(depositRewardsMessage, 'Por favor, conecte su billetera MetaMask y asegúrese de ser el propietario.', 'error');
                return;
            }
            hideMessage(depositRewardsMessage);

            const amount = depositAmountInput.value;
            if (amount <= 0) {
                showMessage(depositRewardsMessage, 'Por favor, introduzca una cantidad válida para aprobar.', 'error');
                return;
            }

            try {
                const amountToApprove = web3.utils.toWei(amount.toString(), 'ether');
                showMessage(depositRewardsMessage, 'Enviando transacción de aprobación para el depósito... Por favor, confirme en MetaMask.', 'info');
                const tx = await oroBitTokenContract.methods.approve(STAKING_CONTRACT_ADDRESS, amountToApprove).send({ from: currentAccount });
                showMessage(depositRewardsMessage, `Aprobación de depósito exitosa. Hash: <a href="https://testnet.bscscan.com/tx/${tx.transactionHash}" target="_blank" class="text-blue-300 hover:underline">Ver Transacción</a>`, 'success');
                console.log("Aprobación de depósito:", tx);
            } catch (error) {
                const decodedError = decodeRevertReason(error.message);
                console.error("Error al aprobar depósito:", error);
                showMessage(depositRewardsMessage, `Error al aprobar depósito: ${decodedError}`, 'error');
            }
        }

        async function handleDepositRewards() {
            if (!web3 || !currentAccount || !stakingContract || !isOwner) {
                showMessage(depositRewardsMessage, 'Por favor, conecte su billetera MetaMask y asegúrese de ser el propietario.', 'error');
                return;
            }
            hideMessage(depositRewardsMessage);

            const amount = depositAmountInput.value;
            if (amount <= 0) {
                showMessage(depositRewardsMessage, 'Por favor, introduzca una cantidad válida para depositar.', 'error');
                return;
            }

            try {
                const amountInWei = web3.utils.toWei(amount.toString(), 'ether');

                // Verificar allowance antes de depositar
                const allowance = await oroBitTokenContract.methods.allowance(currentAccount, STAKING_CONTRACT_ADDRESS).call();
                if (BigInt(allowance) < BigInt(amountInWei)) {
                    showMessage(depositRewardsMessage, 'Cantidad insuficiente aprobada para el contrato de staking. Por favor, apruebe el depósito primero.', 'error');
                    return;
                }

                showMessage(depositRewardsMessage, 'Enviando transacción de depósito de recompensas... Por favor, confirme en MetaMask.', 'info');
                const tx = await stakingContract.methods.depositRewards(amountInWei).send({ from: currentAccount });
                showMessage(depositRewardsMessage, `Recompensas depositadas exitosamente. Hash: <a href="https://testnet.bscscan.com/tx/${tx.transactionHash}" target="_blank" class="text-blue-300 hover:underline">Ver Transacción</a>`, 'success');
                console.log("Recompensas depositadas:", tx);
                depositAmountInput.value = '';
                loadAdminData(); // Actualizar balance del contrato
            } catch (error) {
                const decodedError = decodeRevertReason(error.message);
                console.error("Error al depositar recompensas:", error);
                showMessage(depositRewardsMessage, `Error al depositar recompensas: ${decodedError}`, 'error');
            }
        }

        async function handleEmergencyWithdraw() {
            if (!web3 || !currentAccount || !stakingContract || !isOwner) {
                showMessage(emergencyWithdrawMessage, 'Acceso denegado. Solo el propietario puede realizar retiros de emergencia.', 'error');
                return;
            }
            hideMessage(emergencyWithdrawMessage);

            const tokenAddress = erc20TokenAddressInput.value;
            const amount = erc20WithdrawAmountInput.value;

            if (!web3.utils.isAddress(tokenAddress)) {
                showMessage(emergencyWithdrawMessage, 'Por favor, introduzca una dirección de token ERC20 válida.', 'error');
                return;
            }
            if (tokenAddress.toLowerCase() === OROBIT_TOKEN_ADDRESS.toLowerCase()) {
                 showMessage(emergencyWithdrawMessage, '¡No se puede retirar el token principal de staking (OroBit) con esta función!', 'error');
                 return;
            }
            if (amount <= 0) {
                showMessage(emergencyWithdrawMessage, 'Por favor, introduzca una cantidad válida para retirar.', 'error');
                return;
            }

            try {
                const amountInWei = web3.utils.toWei(amount.toString(), 'ether');
                showMessage(emergencyWithdrawMessage, 'Enviando transacción de retiro de emergencia... Por favor, confirme en MetaMask.', 'info');
                const tx = await stakingContract.methods.emergencyWithdrawToken(tokenAddress, amountInWei).send({ from: currentAccount });
                showMessage(emergencyWithdrawMessage, `Retiro de emergencia exitoso. Hash: <a href="https://testnet.bscscan.com/tx/${tx.transactionHash}" target="_blank" class="text-blue-300 hover:underline">Ver Transacción</a>`, 'success');
                console.log("Retiro de emergencia:", tx);
                erc20TokenAddressInput.value = '';
                erc20WithdrawAmountInput.value = '';
            } catch (error) {
                const decodedError = decodeRevertReason(error.message);
                console.error("Error al realizar retiro de emergencia:", error);
                showMessage(emergencyWithdrawMessage, `Error al realizar retiro de emergencia: ${decodedError}`, 'error');
            }
        }


        // --- Event Listeners ---
        approveButton.addEventListener('click', handleApprove);
        stakeButton.addEventListener('click', handleStake);
        withdrawButton.addEventListener('click', handleWithdraw);
        addPoolButton.addEventListener('click', handleAddPool);
        updatePoolStatusButton.addEventListener('click', handleUpdatePoolStatus);
        setPenaltyButton.addEventListener('click', handleSetPenalty);
        setWhaleBonusAprButton.addEventListener('click', handleSetWhaleBonusApr);
        setWhaleThresholdButton.addEventListener('click', handleSetWhaleThreshold);
        approveDepositButton.addEventListener('click', handleApproveDeposit);
        depositRewardsButton.addEventListener('click', handleDepositRewards);
        emergencyWithdrawButton.addEventListener('click', handleEmergencyWithdraw);

        // --- Inicialización al cargar la ventana ---
        window.addEventListener('load', () => {
            connectWallet();
            showTab('stake'); // Mostrar la pestaña de Stakear por defecto
        });
    </script>
</body>
</html>
