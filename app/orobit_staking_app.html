<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OroBitverse Staking App</title>
    <!-- Favicon de OroBit - Usando el logo de 1280x720px, que es el que tienes confirmado -->
    <link rel="icon" href="../images/orobit_logo_1280x720.png" type="image/png">

    <!-- Content Security Policy (CSP) - IMPORTANTE PARA PRODUCCIÓN -->
    <!-- Considera habilitar un CSP más estricto en producción. Esto es una base. -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self' data: https://cdn.tailwindcss.com https://cdnjs.cloudflare.com;
        script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com https://cdn.ethers.io;
        style-src 'self' 'unsafe-inline' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com;
        img-src 'self' data: https://placehold.co https://* ;
        font-src 'self' https://cdnjs.cloudflare.com;
        connect-src 'self' https://testnet.bscscan.com https://api-testnet.bscscan.com https://data-seed-prebsc-1-s1.binance.org:8545 https://bsc-testnet.public.blastapi.io https://bsc-testnet.drpc.org;
        object-src 'none';
        base-uri 'self';
    ">

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Ethers.js CDN para interacción con Web3 -->
    <script src="https://cdn.ethers.io/lib/ethers-5.2.umd.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* bg-gray-900 oscuro */
            color: #e2e8f0; /* text-gray-200 */
        }
        .btn-primary {
            background: linear-gradient(to right, #FFD700, #FFA500); /* Dorado */
            color: #333;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.4);
        }
        .btn-primary:hover {
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.7);
            transform: translateY(-2px);
        }
        .btn-secondary {
            background: linear-gradient(to right, #6366f1, #8b5cf6); /* Azul-Púrpura */
            color: white;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(99, 102, 241, 0.4);
        }
        .btn-secondary:hover {
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.7);
            transform: translateY(-2px);
        }
        .tab-button.active {
            border-bottom: 3px solid #FFD700;
            color: #FFD700;
        }
        .card {
            background-color: rgba(45, 55, 72, 0.6); /* bg-gray-700 con opacidad */
            backdrop-filter: blur(5px);
            border: 1px solid rgba(74, 85, 104, 0.5); /* border-gray-600 con opacidad */
        }
        /* Animación para el logo */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .animate-pulse-effect {
            animation: pulse 2s infinite ease-in-out;
        }
        /* Estilos para el texto de neón (OroBitverse) */
        .neon-text {
            text-shadow: 0 0 5px #8B5CF6, 0 0 10px #8B5CF6, 0 0 15px #8B5CF6, 0 0 20px #8B5CF6; /* purple-500 */
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 min-h-screen flex flex-col items-center">

    <!-- Header / Navbar -->
    <header class="w-full bg-gray-800 bg-opacity-70 backdrop-filter backdrop-blur-lg sticky top-0 z-50 shadow-lg py-4">
        <nav class="container mx-auto px-4 flex justify-between items-center">
            <div class="flex items-center">
                <!-- Logo con animación - Usando orobit_logo_1280x720.png -->
                <img src="../images/orobit_logo_1280x720.png" alt="OroBitverse Logo" class="h-10 mr-3 animate-pulse-effect rounded-lg">
                <a href="#" class="text-2xl font-bold text-yellow-400 neon-text">OroBitverse</a>
            </div>
            <div class="flex items-center space-x-4">
                <!-- Estado de la billetera: Desconectado, Conectando..., Conectado -->
                <span id="walletAddressDisplay" class="text-gray-400 text-sm md:text-base">Desconectado</span>
                <!-- Botón de Conectar/Desconectar Cartera -->
                <button id="connectWalletBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-full transition duration-300">
                    Conectar Cartera
                </button>
            </div>
        </nav>
    </header>

    <main class="container mx-auto p-4 mt-8 flex-grow">
        <!-- Message Box para alertas personalizadas -->
        <div id="messageBox" class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-yellow-400 text-gray-900 p-6 rounded-lg shadow-xl z-50 hidden" role="alert">
            <p id="messageText" class="text-lg font-semibold"></p>
            <button id="closeMessageBox" class="mt-4 bg-gray-800 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-full float-right">Cerrar</button>
        </div>

        <div class="bg-gray-800 p-6 rounded-xl shadow-xl">
            <!-- Pestañas de navegación -->
            <div class="flex justify-center border-b border-gray-700 mb-6">
                <button id="dashboardTab" class="tab-button py-3 px-6 text-lg font-semibold transition duration-300 active">
                    Mi Dashboard
                </button>
                <button id="stakeTab" class="tab-button py-3 px-6 text-lg font-semibold transition duration-300">
                    Stakear
                </button>
                <button id="withdrawTab" class="tab-button py-3 px-6 text-lg font-semibold transition duration-300">
                    Retirar
                </button>
                <button id="adminTab" class="tab-button py-3 px-6 text-lg font-semibold transition duration-300">
                    Admin
                </button>
            </div>

            <!-- Contenido del Dashboard -->
            <div id="dashboardContent" class="tab-content">
                <h2 class="text-3xl font-bold text-yellow-400 mb-6 text-center">Mi Dashboard</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                    <div class="card p-6 rounded-xl shadow-md">
                        <h3 class="text-xl font-semibold text-blue-300 mb-3">Balance OroBit</h3>
                        <p id="oroBitBalance" class="text-3xl font-bold">0.00 OROBIT</p>
                    </div>
                    <div class="card p-6 rounded-xl shadow-md">
                        <h3 class="text-xl font-semibold text-green-300 mb-3">Recompensas Totales Acumuladas</h3>
                        <p id="totalRewards" class="text-3xl font-bold">0.00 OROBIT</p>
                    </div>
                </div>

                <h3 class="text-2xl font-bold text-yellow-300 mb-4">Mis Stakes Activos</h3>
                <div id="activeStakes" class="space-y-4">
                    <!-- Los stakes activos se cargarán aquí -->
                    <p class="text-gray-400" id="noActiveStakesMessage">No tienes stakes activos.</p>
                </div>
            </div>

            <!-- Contenido de Staking -->
            <div id="stakeContent" class="tab-content hidden">
                <h2 class="text-3xl font-bold text-yellow-400 mb-6 text-center">Stakear OroBit</h2>
                <div class="card p-8 rounded-xl shadow-lg max-w-lg mx-auto">
                    <div class="mb-4">
                        <label for="stakeAmount" class="block text-gray-300 text-sm font-bold mb-2">Cantidad a Stakear (OROBIT):</label>
                        <div class="flex items-center border border-gray-600 rounded-lg overflow-hidden">
                            <input type="number" id="stakeAmount" class="shadow appearance-none border-none rounded w-full py-3 px-4 bg-gray-700 text-gray-200 leading-tight focus:outline-none focus:shadow-outline" placeholder="Ej. 1000">
                            <button id="maxStakeBtn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-r-lg transition duration-300">MAX</button>
                        </div>
                        <p class="text-gray-400 text-sm mt-1">Balance Disponible: <span id="availableBalance">0.00 OROBIT</span></p>
                    </div>

                    <div class="mb-6">
                        <label for="stakingPool" class="block text-gray-300 text-sm font-bold mb-2">Seleccionar Pool de Staking:</label>
                        <select id="stakingPool" class="shadow border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200 leading-tight focus:outline-none focus:shadow-outline">
                            <!-- Opciones de pools se cargarán aquí dinámicamente -->
                        </select>
                    </div>

                    <button id="approveBtn" class="w-full btn-secondary font-bold py-3 px-6 rounded-xl text-lg mb-4">
                        Aprobar OroBit
                    </button>
                    <button id="stakeBtn" class="w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">
                        Confirmar Stake
                    </button>
                </div>
            </div>

            <!-- Contenido de Retiro -->
            <div id="withdrawContent" class="tab-content hidden">
                <h2 class="text-3xl font-bold text-yellow-400 mb-6 text-center">Retirar Stake y Recompensas</h2>
                <div class="card p-8 rounded-xl shadow-lg max-w-lg mx-auto">
                    <div class="mb-4">
                        <label for="withdrawStakeId" class="block text-gray-300 text-sm font-bold mb-2">ID de tu Stake a Retirar:</label>
                        <input type="number" id="withdrawStakeId" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200 leading-tight focus:outline-none focus:shadow-outline" placeholder="Ej. 0">
                    </div>
                    <button id="calculateRewardBtn" class="w-full btn-secondary font-bold py-3 px-6 rounded-xl text-lg mb-4">
                        Calcular Recompensa
                    </button>
                    <p id="calculatedRewardDisplay" class="text-center text-lg text-green-300 mb-6 hidden">
                        Recompensa estimada: <span class="font-bold">0.00 OROBIT</span>
                    </p>
                    <button id="withdrawConfirmBtn" class="w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">
                        Retirar Stake
                    </button>
                </div>
            </div>

            <!-- Contenido de Admin (solo para el propietario) -->
            <div id="adminContent" class="tab-content hidden">
                <h2 class="text-3xl font-bold text-yellow-400 mb-6 text-center">Panel de Administración</h2>
                <p id="adminMessage" class="text-red-400 text-center mb-6 hidden">
                    Acceso restringido. Solo el propietario del contrato puede ver este panel.
                </p>

                <div id="adminPanel" class="space-y-8 hidden">
                    <!-- Sección Añadir Pool -->
                    <div class="card p-8 rounded-xl shadow-lg">
                        <h3 class="text-2xl font-bold text-blue-300 mb-4">Añadir Nuevo Pool de Staking</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <label for="poolDuration" class="block text-gray-300 text-sm font-bold mb-2">Duración (segundos, 0 para flexible):</label>
                                <input type="number" id="poolDuration" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="Ej. 2592000 (30 días)">
                            </div>
                            <div>
                                <label for="poolAPR" class="block text-gray-300 text-sm font-bold mb-2">APR (puntos base, Ej. 500 para 5%):</label>
                                <input type="number" id="poolAPR" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="Ej. 500">
                            </div>
                        </div>
                        <div class="mt-4 flex items-center">
                            <input type="checkbox" id="isFlexiblePool" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                            <label for="isFlexiblePool" class="ml-2 text-gray-300">Es Flexible</label>
                        </div>
                        <button id="addPoolBtn" class="mt-6 w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">Añadir Pool</button>
                    </div>

                    <!-- Sección Actualizar Estado de Pool -->
                    <div class="card p-8 rounded-xl shadow-lg">
                        <h3 class="text-2xl font-bold text-blue-300 mb-4">Actualizar Estado de Pool Existente</h3>
                        <div class="mb-4">
                            <label for="poolIdStatus" class="block text-gray-300 text-sm font-bold mb-2">ID del Pool:</label>
                            <input type="number" id="poolIdStatus" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="Ej. 0">
                        </div>
                        <div class="mt-4 flex items-center">
                            <input type="checkbox" id="isActivePool" class="form-checkbox h-5 w-5 text-green-600 rounded" checked>
                            <label for="isActivePool" class="ml-2 text-gray-300">Activo</label>
                        </div>
                        <button id="setPoolStatusBtn" class="mt-6 w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">Actualizar Estado</button>
                    </div>

                    <!-- Sección Actualizar Penalización Retiro Anticipado -->
                    <div class="card p-8 rounded-xl shadow-lg">
                        <h3 class="text-2xl font-bold text-blue-300 mb-4">Configuración de Penalizaciones y Bonus</h3>
                        <div class="mb-4">
                            <label for="earlyWithdrawPenalty" class="block text-gray-300 text-sm font-bold mb-2">Penalización Retiro Anticipado (puntos base, Ej. 2000 para 20%):</label>
                            <input type="number" id="earlyWithdrawPenalty" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="Ej. 2000">
                        </div>
                        <button id="setPenaltyBtn" class="mt-6 w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">Establecer Penalización</button>
                        
                        <div class="mt-6 mb-4">
                            <label for="whaleBonusAPR" class="block text-gray-300 text-sm font-bold mb-2">Bonus APR para Ballenas (puntos base, Ej. 100 para 1%):</label>
                            <input type="number" id="whaleBonusAPR" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="Ej. 100">
                        </div>
                        <button id="setWhaleBonusAPRBtn" class="mt-6 w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">Establecer Bonus APR Ballenas</button>

                        <div class="mt-6 mb-4">
                            <label for="whaleThreshold" class="block text-gray-300 text-sm font-bold mb-2">Umbral de Ballena (OROBIT, Ej. 500000):</label>
                            <input type="number" id="whaleThreshold" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="Ej. 500000">
                        </div>
                        <button id="setWhaleThresholdBtn" class="mt-6 w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">Establecer Umbral Ballenas</button>
                    </div>

                    <!-- Sección Depositar Recompensas -->
                    <div class="card p-8 rounded-xl shadow-lg">
                        <h3 class="text-2xl font-bold text-blue-300 mb-4">Depositar Recompensas</h3>
                        <div class="mb-4">
                            <label for="rewardsAmount" class="block text-gray-300 text-sm font-bold mb-2">Cantidad de OroBit a Depositar:</label>
                            <input type="number" id="rewardsAmount" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="Ej. 1000">
                        </div>
                        <button id="depositRewardsBtn" class="mt-6 w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">Depositar Recompensas</button>
                    </div>

                    <!-- Sección Cambiar Cartera de Admin -->
                    <div class="card p-8 rounded-xl shadow-lg">
                        <h3 class="text-2xl font-bold text-blue-300 mb-4">Cambiar Cartera de Administración de Staking</h3>
                        <div class="mb-4">
                            <label for="newAdminWalletAddress" class="block text-gray-300 text-sm font-bold mb-2">Nueva Dirección de Cartera:</label>
                            <input type="text" id="newAdminWalletAddress" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="0x...">
                        </div>
                        <button id="setAdminWalletBtn" class="mt-6 w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">Establecer Cartera de Admin</button>
                    </div>

                    <!-- Sección Retiro de Tokens de Emergencia -->
                    <div class="card p-8 rounded-xl shadow-lg">
                        <h3 class="text-2xl font-bold text-blue-300 mb-4">Retiro de Tokens de Emergencia</h3>
                        <div class="mb-4">
                            <label for="emergencyTokenAddress" class="block text-gray-300 text-sm font-bold mb-2">Dirección del Token (ERC20):</label>
                            <input type="text" id="emergencyTokenAddress" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="0x...">
                        </div>
                        <div class="mb-4">
                            <label for="emergencyAmount" class="block text-gray-300 text-sm font-bold mb-2">Cantidad a Retirar:</label>
                            <input type="number" id="emergencyAmount" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="Ej. 1000">
                        </div>
                        <button id="emergencyWithdrawBtn" class="mt-6 w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">Retirar Tokens de Emergencia</button>
                    </div>

                    <!-- Sección Pausar/Reanudar Contrato -->
                    <div class="card p-8 rounded-xl shadow-lg">
                        <h3 class="text-2xl font-bold text-blue-300 mb-4">Control de Pausa del Contrato</h3>
                        <button id="pauseContractBtn" class="mt-6 w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg mb-4">Pausar Contrato</button>
                        <button id="unpauseContractBtn" class="w-full btn-secondary font-bold py-3 px-6 rounded-xl text-lg">Reanudar Contrato</button>
                    </div>

                </div>
            </div>
        </div>
    </main>

    <footer class="w-full bg-gray-800 py-6 mt-8">
        <div class="container mx-auto px-4 text-center text-gray-500 text-sm">
            <p>&copy; 2025 OroBitverse. Todos los derechos reservados.</p>
        </div>
    </footer>

    <script>
        // --- Constantes de Contrato y Red (BNB Smart Chain Testnet) ---
        const OROBIT_TOKEN_ADDRESS = "0x8bC4B9238047843C3Cb0508b9EdeB3a7729D72c3"; // Token OroBit
        const STAKING_CONTRACT_ADDRESS = "0x8278ebadbc25beea94d6370174b8eeb7b5bfd253"; // Contrato de Staking
        const OWNER_ADDRESS = "0x0C6DA70B1BB307D78d154ec6adbD57ff696E0660"; // Dirección del propietario del contrato

        const CHAIN_ID = "0x61"; // ID de la cadena para BNB Smart Chain Testnet (97 en decimal)
        const CHAIN_NAME = "BNB Smart Chain Testnet";
        const RPC_URL = "https://data-seed-prebsc-1-s1.binance.org:8545";
        const BLOCK_EXPLORER_URL = "https://testnet.bscscan.com";

        const SECONDS_IN_YEAR = 31536000; // Constante para cálculos de duración (365 días * 24 horas * 60 minutos * 60 segundos)


        // ABIs (Application Binary Interfaces)
        // ABI del Token OroBit (IERC20 simplificado)
        const OROBIT_TOKEN_ABI = [
            "function balanceOf(address account) view returns (uint256)",
            "function transfer(address to, uint256 amount) returns (bool)",
            "function approve(address spender, uint256 amount) returns (bool)",
            "function allowance(address owner, address spender) view returns (uint256)",
            "event Transfer(address indexed from, address indexed to, uint256 value)",
            "event Approval(address indexed owner, address indexed spender, uint256 value)"
        ];

        // ABI del Contrato de Staking (OroBitStakingVault)
        const STAKING_CONTRACT_ABI = [
            "function owner() view returns (address)",
            "function paused() view returns (bool)",
            "function addPool(uint256 _duration, uint256 _aprBP, bool _isFlexible) onlyOwner",
            "function setPoolStatus(uint256 _poolId, bool _isActive) onlyOwner",
            "function setWhaleBonusAPR(uint256 _newAPR_BP) onlyOwner",
            "function setWhaleThreshold(uint256 _newThreshold) onlyOwner",
            "function setEarlyWithdrawPenalty(uint256 _newPenaltyBP) onlyOwner",
            "function setStakingAdminWallet(address _newAdminWallet) onlyOwner",
            "function depositRewards(uint256 _amount) nonReentrant onlyOwner",
            "function emergencyWithdrawToken(address _tokenAddress, uint256 _amount) nonReentrant onlyOwner",
            "function pause() onlyOwner",
            "function unpause() onlyOwner",
            "function stake(uint256 _poolId, uint256 _amount) nonReentrant whenNotPaused",
            "function calculateReward(address _user, uint256 _stakeId) view returns (uint256 reward)",
            "function withdraw(uint256 _stakeId) nonReentrant whenNotPaused",
            "function getUserStakesLength(address _user) view returns (uint256)",
            "function getUserStake(address _user, uint256 _stakeId) view returns (uint256 amount, uint256 startTime, uint256 duration, uint256 aprBP, bool withdrawn, uint256 lastRewardClaimTime)",
            "function getPool(uint256 _poolId) view returns (uint256 duration, uint256 aprBP, bool isActive, bool isFlexible)",
            "function getStakingPoolsLength() view returns (uint256)",
            "function getContractTokenBalance() view returns (uint256)"
        ];

        // --- Variables Globales ---
        let provider;
        let signer;
        let userAddress;
        let oroBitTokenContract;
        let stakingContract;
        let publicProvider; // Proveedor público para leer datos sin conexión de usuario

        // --- Elementos del DOM ---
        const connectWalletBtn = document.getElementById('connectWalletBtn');
        const walletAddressDisplay = document.getElementById('walletAddressDisplay');
        const dashboardTab = document.getElementById('dashboardTab');
        const stakeTab = document.getElementById('stakeTab');
        const withdrawTab = document.getElementById('withdrawTab');
        const adminTab = document.getElementById('adminTab');
        const dashboardContent = document.getElementById('dashboardContent');
        const stakeContent = document.getElementById('stakeContent');
        const withdrawContent = document.getElementById('withdrawContent');
        const adminContent = document.getElementById('adminContent');
        const adminPanel = document.getElementById('adminPanel');
        const adminMessage = document.getElementById('adminMessage');
        const messageBox = document.getElementById('messageBox');
        const messageText = document.getElementById('messageText');
        const closeMessageBox = document.getElementById('closeMessageBox');

        // Dashboard
        const oroBitBalanceDisplay = document.getElementById('oroBitBalance');
        const totalRewardsDisplay = document.getElementById('totalRewards');
        const activeStakesDiv = document.getElementById('activeStakes');
        const noActiveStakesMessage = document.getElementById('noActiveStakesMessage');

        // Staking
        const stakeAmountInput = document.getElementById('stakeAmount');
        const maxStakeBtn = document.getElementById('maxStakeBtn');
        const availableBalanceDisplay = document.getElementById('availableBalance');
        const stakingPoolSelect = document.getElementById('stakingPool');
        const approveBtn = document.getElementById('approveBtn');
        const stakeBtn = document.getElementById('stakeBtn');

        // Withdraw
        const withdrawStakeIdInput = document.getElementById('withdrawStakeId');
        const calculateRewardBtn = document.getElementById('calculateRewardBtn');
        const calculatedRewardDisplay = document.getElementById('calculatedRewardDisplay');
        const withdrawConfirmBtn = document.getElementById('withdrawConfirmBtn');

        // Admin
        const poolDurationInput = document.getElementById('poolDuration');
        const poolAPRInput = document.getElementById('poolAPR'); 
        const isFlexiblePoolCheckbox = document.getElementById('isFlexiblePool');
        const addPoolBtn = document.getElementById('addPoolBtn');
        const poolIdStatusInput = document.getElementById('poolIdStatus');
        const isActivePoolCheckbox = document.getElementById('isActivePool');
        const setPoolStatusBtn = document.getElementById('setPoolStatusBtn');
        const earlyWithdrawPenaltyInput = document.getElementById('earlyWithdrawPenalty');
        const setPenaltyBtn = document.getElementById('setPenaltyBtn');
        const whaleBonusAPRInput = document.getElementById('whaleBonusAPR');
        const setWhaleBonusAPRBtn = document.getElementById('setWhaleBonusAPRBtn');
        const whaleThresholdInput = document.getElementById('whaleThreshold');
        const setWhaleThresholdBtn = document.getElementById('setWhaleThresholdBtn');
        const rewardsAmountInput = document.getElementById('rewardsAmount');
        const depositRewardsBtn = document.getElementById('depositRewardsBtn');
        const newAdminWalletAddressInput = document.getElementById('newAdminWalletAddress');
        const setAdminWalletBtn = document.getElementById('setAdminWalletBtn');
        const emergencyTokenAddressInput = document.getElementById('emergencyTokenAddress');
        const emergencyAmountInput = document.getElementById('emergencyAmount');
        const emergencyWithdrawBtn = document.getElementById('emergencyWithdrawBtn');
        const pauseContractBtn = document.getElementById('pauseContractBtn');
        const unpauseContractBtn = document.getElementById('unpauseContractBtn');


        // --- Funciones de Utilidad ---

        let messageBoxTimeout; // Para limpiar timeouts anteriores

        /**
         * @dev Muestra un mensaje en un cuadro de diálogo flotante.
         * @param {string} message El texto del mensaje.
         * @param {string} type El tipo de mensaje ('success', 'error', 'info', 'warning').
         */
        function showMessage(message, type = 'info') {
            console.log(`[showMessage] Tipo: ${type}, Mensaje: ${message}`); // DEBUG: Log del mensaje
            messageText.textContent = message;
            messageBox.className = 'fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 p-6 rounded-lg shadow-xl z-50'; // Reset classes
            messageBox.classList.remove('hidden');

            // Limpiar cualquier timeout anterior antes de establecer uno nuevo
            if (messageBoxTimeout) {
                clearTimeout(messageBoxTimeout);
            }
            // Ocultar automáticamente después de 5 segundos
            messageBoxTimeout = setTimeout(() => {
                hideMessageBox();
            }, 5000);

            switch (type) {
                case 'success':
                    messageBox.classList.add('bg-green-500', 'text-white');
                    break;
                case 'error':
                    messageBox.classList.add('bg-red-500', 'text-white');
                    break;
                case 'warning':
                    messageBox.classList.add('bg-yellow-400', 'text-gray-900');
                    break;
                case 'info':
                default:
                    messageBox.classList.add('bg-blue-500', 'text-white');
                    break;
            }
        }

        /**
         * @dev Oculta el cuadro de diálogo de mensajes.
         */
        function hideMessageBox() {
            console.log("[hideMessageBox] Ocultando messageBox."); // DEBUG: Log de ocultamiento
            messageBox.classList.add('hidden');
            if (messageBoxTimeout) {
                clearTimeout(messageBoxTimeout); // Limpiar timeout si se oculta manualmente
                messageBoxTimeout = null;
            }
        }

        /**
         * @dev Actualiza el color y texto del botón de conexión y la pantalla de la dirección de la billetera.
         * @param {'disconnected'|'connecting'|'connected'|'install'} state El estado de conexión.
         * @param {string} address La dirección de la billetera (opcional, para estado 'connected').
         */
        function updateConnectionUI(state, address = '') {
            console.log(`[updateConnectionUI] Nuevo estado: ${state}`); // DEBUG: Log del cambio de UI
            // Eliminar todas las clases de color existentes
            connectWalletBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'bg-yellow-600', 'hover:bg-yellow-700', 'bg-green-600', 'hover:bg-green-700', 'bg-red-600', 'hover:bg-red-700');
            walletAddressDisplay.classList.remove('text-gray-400', 'text-yellow-400', 'text-green-400', 'text-red-400');

            switch (state) {
                case 'connecting':
                    walletAddressDisplay.textContent = 'Conectando...';
                    walletAddressDisplay.classList.add('text-yellow-400');
                    connectWalletBtn.textContent = 'Conectando...';
                    connectWalletBtn.classList.add('bg-yellow-600', 'hover:bg-yellow-700');
                    connectWalletBtn.disabled = true; // Deshabilitar durante la conexión
                    break;
                case 'connected':
                    walletAddressDisplay.textContent = `Conectado: ${shortenAddress(address)}`;
                    walletAddressDisplay.classList.add('text-green-400');
                    connectWalletBtn.textContent = 'Desconectar';
                    connectWalletBtn.classList.add('bg-green-600', 'hover:bg-green-700');
                    connectWalletBtn.disabled = false;
                    connectWalletBtn.onclick = disconnectWallet;
                    break;
                case 'install':
                    walletAddressDisplay.textContent = 'MetaMask no detectado';
                    walletAddressDisplay.classList.add('text-red-400');
                    connectWalletBtn.textContent = 'Instalar MetaMask';
                    connectWalletBtn.classList.add('bg-red-600', 'hover:bg-red-700');
                    connectWalletBtn.disabled = false;
                    connectWalletBtn.onclick = () => window.open('https://metamask.io/download/', '_blank');
                    break;
                case 'disconnected':
                default:
                    walletAddressDisplay.textContent = 'Desconectado';
                    walletAddressDisplay.classList.add('text-gray-400');
                    connectWalletBtn.textContent = 'Conectar Cartera';
                    connectWalletBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
                    connectWalletBtn.disabled = false;
                    connectWalletBtn.onclick = connectWallet; // Asegurar que el click intente conectar
                    break;
            }
        }

        /**
         * @dev Cambia la visibilidad de las pestañas de contenido.
         * @param {HTMLElement} targetContent La pestaña de contenido a mostrar.
         * @param {HTMLElement} targetTab El botón de la pestaña a activar.
         */
        function showTab(targetContent, targetTab) {
            // Ocultar todos los contenidos y desactivar todos los botones
            document.querySelectorAll('.tab-content').forEach(content => content.classList.add('hidden'));
            document.querySelectorAll('.tab-button').forEach(button => button.classList.remove('active'));

            // Mostrar el contenido objetivo y activar el botón objetivo
            targetContent.classList.remove('hidden');
            targetTab.classList.add('active');

            // Cargar datos específicos si es necesario
            if (targetContent === dashboardContent && userAddress) {
                loadDashboardData();
            }
            if (targetContent === stakeContent) { // Cargar pools siempre, incluso sin conexión
                loadStakingPools();
                if (userAddress) { // Solo actualizar balance si hay conexión
                    updateAvailableBalance();
                } else {
                    availableBalanceDisplay.textContent = 'Conecta tu cartera';
                }
            }
        }

        /**
         * @dev Convierte un número de wei a unidades de token (con 18 decimales).
         * @param {BigNumber} weiAmount Cantidad en wei.
         * @returns {string} Cantidad formateada como string.
         */
        function formatUnits(weiAmount) {
            if (!weiAmount) return "0.00";
            return ethers.utils.formatUnits(weiAmount, 18);
        }

        /**
         * @dev Convierte un número de unidades de token a wei (con 18 decimales).
         * @param {string | number} tokenAmount Cantidad en unidades de token.
         * @returns {BigNumber} Cantidad en wei.
         */
        function parseUnits(tokenAmount) {
            if (!tokenAmount) return ethers.constants.Zero;
            return ethers.utils.parseUnits(String(tokenAmount), 18);
        }

        /**
         * @dev Formatea una dirección de billetera para mostrarla acortada.
         * @param {string} address La dirección completa.
         * @returns {string} La dirección acortada.
         */
        function shortenAddress(address) {
            if (!address) return '';
            return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
        }

        /**
         * @dev Añade la red de BNB Smart Chain Testnet a MetaMask si no está.
         */
        async function addBscTestnetNetwork() {
            try {
                await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [{
                        chainId: CHAIN_ID,
                        chainName: CHAIN_NAME,
                        rpcUrls: [RPC_URL],
                        nativeCurrency: {
                            name: "BNB",
                            symbol: "tBNB",
                            decimals: 18
                        },
                        blockExplorerUrls: [BLOCK_EXPLORER_URL]
                    }]
                });
                return true;
            } catch (error) {
                console.error("Error adding BSC Testnet network:", error);
                showMessage(`Error al añadir la red: ${error.message}`, 'error');
                return false;
            }
        }

        /**
         * @dev Cambia a la red de BNB Smart Chain Testnet en MetaMask.
         * @returns {boolean} True si el cambio fue exitoso o ya estaba en la red, false en caso contrario.
         */
        async function switchToBscTestnet() {
            try {
                const currentChainId = await window.ethereum.request({ method: 'eth_chainId' });
                if (currentChainId.toLowerCase() !== CHAIN_ID.toLowerCase()) {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: CHAIN_ID }]
                    });
                }
                return true;
            } catch (switchError) {
                // Si la red no ha sido agregada a MetaMask, se puede intentar agregarla.
                if (switchError.code === 4902) {
                    console.warn("BSC Testnet not found, attempting to add it.");
                    showMessage('BNB Smart Chain Testnet no está en tu MetaMask. Intentando añadirla...', 'info');
                    return await addBscTestnetNetwork();
                } else {
                    console.error("Error switching network:", switchError);
                    showMessage(`Error al cambiar de red: ${switchError.message}`, 'error');
                    return false;
                }
            }
        }

        // --- Funciones de Interacción con Web3 ---

        /**
         * @dev Conecta la billetera del usuario a la DApp.
         */
        async function connectWallet() {
            hideMessageBox(); // Asegurarse de que cualquier mensaje previo se oculte al inicio de la conexión

            if (typeof window.ethereum === 'undefined') {
                updateConnectionUI('install'); // Actualizar UI a estado de instalación
                showMessage('MetaMask no está instalado. Por favor, instálalo para usar esta DApp.', 'warning');
                return;
            }

            updateConnectionUI('connecting'); // Mostrar estado "Conectando..."

            try {
                // Solicitar cuentas. Esto disparará una solicitud de conexión si no está ya conectado.
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                userAddress = accounts[0];
                console.log("Wallet connected, user address:", userAddress);

                // Cambiar a la red correcta o añadirla DESPUÉS de obtener las cuentas
                const networkSwitched = await switchToBscTestnet();
                if (!networkSwitched) {
                    showMessage('Por favor, conecta MetaMask a la BNB Smart Chain Testnet.', 'error');
                    disconnectWallet(); // Desconectar si la red no es correcta y revertir UI
                    return;
                }

                provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner();

                // Inicializar contratos con el signer (para transacciones)
                oroBitTokenContract = new ethers.Contract(OROBIT_TOKEN_ADDRESS, OROBIT_TOKEN_ABI, signer);
                stakingContract = new ethers.Contract(STAKING_CONTRACT_ADDRESS, STAKING_CONTRACT_ABI, signer);

                updateConnectionUI('connected', userAddress); // Actualizar UI a estado "Conectado"
                showMessage('¡Billetera conectada a BNB Smart Chain Testnet!', 'success');
                // Cargar datos iniciales del dashboard
                loadDashboardData();
                checkAdminAccess();
                updateAvailableBalance();
                
                // Escuchar cambios de cuenta y red
                // Solo añadir listeners una vez para evitar duplicados
                if (!window.ethereum._has_listeners) { // Propiedad personalizada para evitar duplicados
                    window.ethereum.on('accountsChanged', handleAccountsChanged);
                    window.ethereum.on('chainChanged', handleChainChanged);
                    window.ethereum._has_listeners = true; // Marcar que los listeners han sido añadidos
                }

            } catch (error) {
                console.error("Error en connectWallet:", error);
                // Si el usuario rechaza la conexión, MetaMask lanza un error con code 4001
                if (error.code === 4001) {
                    showMessage('Conexión a MetaMask rechazada. Por favor, acepta la conexión.', 'warning');
                } else {
                    showMessage(`Error al conectar la billetera: ${error.message}`, 'error');
                }
                disconnectWallet(); // Asegurarse de que la UI refleje el estado desconectado
            }
        }

        /**
         * @dev Desconecta la billetera del usuario.
         */
        function disconnectWallet() {
            userAddress = null;
            provider = null;
            signer = null;
            oroBitTokenContract = null;
            stakingContract = null;

            hideMessageBox(); // Asegurarse de que el messageBox se oculte al desconectar
            updateConnectionUI('disconnected'); // Actualizar UI a estado "Desconectado"

            // Limpiar datos del dashboard y otros elementos de la UI
            oroBitBalanceDisplay.textContent = '0.00 OROBIT';
            totalRewardsDisplay.textContent = '0.00 OROBIT';
            activeStakesDiv.innerHTML = '<p class="text-gray-400" id="noActiveStakesMessage">No tienes stakes activos.</p>';
            availableBalanceDisplay.textContent = 'Conecta tu cartera'; // Resetear a mensaje de conexión
            adminPanel.classList.add('hidden');
            adminMessage.classList.remove('hidden'); // Mostrar mensaje de acceso restringido
            
            // Eliminar listeners para evitar fugas de memoria si se reconecta.
            if (window.ethereum && window.ethereum._has_listeners) {
                window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
                window.ethereum.removeListener('chainChanged', handleChainChanged);
                window.ethereum._has_listeners = false;
            }
        }

        /**
         * @dev Maneja el cambio de cuenta en MetaMask.
         * @param {string[]} accounts Las nuevas cuentas.
         */
        function handleAccountsChanged(accounts) {
            console.log("Accounts changed:", accounts);
            if (accounts.length === 0) {
                // MetaMask está bloqueado o el usuario desconectó todas las cuentas
                disconnectWallet();
                showMessage('Tu billetera ha sido desconectada. Por favor, reconecta.', 'warning');
            } else if (userAddress && accounts[0].toLowerCase() !== userAddress.toLowerCase()) {
                userAddress = accounts[0];
                provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner();
                oroBitTokenContract = new ethers.Contract(OROBIT_TOKEN_ADDRESS, OROBIT_TOKEN_ABI, signer);
                stakingContract = new ethers.Contract(STAKING_CONTRACT_ADDRESS, STAKING_CONTRACT_ABI, signer);

                updateConnectionUI('connected', userAddress); // Actualizar UI a estado "Conectado"
                showMessage(`Cuenta cambiada a: ${shortenAddress(userAddress)}`, 'info');
                loadDashboardData(); // Recargar datos para la nueva cuenta
                checkAdminAccess(); // Re-chequear acceso de admin
                updateAvailableBalance(); // Actualizar balance
            } else if (!userAddress && accounts.length > 0) {
                // Caso en que no estábamos conectados y ahora sí hay cuentas
                connectWallet(); // Intentar una conexión completa
            }
        }

        /**
         * @dev Maneja el cambio de red en MetaMask.
         * @param {string} chainId Hexadecimal ID de la nueva cadena.
         */
        function handleChainChanged(chainId) {
            console.log("Chain changed to:", chainId);
            if (chainId.toLowerCase() !== CHAIN_ID.toLowerCase()) {
                showMessage('Has cambiado a una red incorrecta. Intentando cambiar a BNB Smart Chain Testnet...', 'warning');
                switchToBscTestnet().then(success => {
                    if (success) {
                        connectWallet(); // Reconectar para asegurar que todo se reinicialice correctamente
                    } else {
                        showMessage('Falló el cambio automático de red. Por favor, hazlo manualmente.', 'error');
                        disconnectWallet();
                    }
                });
            } else {
                showMessage('Conectado a BNB Smart Chain Testnet.', 'success');
                connectWallet(); // Re-inicializar si ya estamos en la red correcta
            }
        }


        /**
         * @dev Carga y muestra los datos del dashboard del usuario.
         */
        async function loadDashboardData() {
            if (!userAddress || !oroBitTokenContract || !stakingContract) {
                oroBitBalanceDisplay.textContent = 'Conecta tu cartera';
                totalRewardsDisplay.textContent = 'Conecta tu cartera';
                activeStakesDiv.innerHTML = '<p class="text-gray-400" id="noActiveStakesMessage">No tienes stakes activos.</p>';
                return;
            }

            try {
                // Balance de OroBit del usuario
                const balance = await oroBitTokenContract.balanceOf(userAddress);
                oroBitBalanceDisplay.textContent = `${formatUnits(balance)} OROBIT`;
                availableBalanceDisplay.textContent = `${formatUnits(balance)} OROBIT`;

                // Stakes activos del usuario
                const userStakesLength = await stakingContract.getUserStakesLength(userAddress);
                activeStakesDiv.innerHTML = ''; // Limpiar stakes existentes
                let totalRewardsAccumulated = ethers.constants.Zero;

                if (userStakesLength == 0) {
                    activeStakesDiv.innerHTML = '<p class="text-gray-400" id="noActiveStakesMessage">No tienes stakes activos.</p>';
                } else {
                    if (document.getElementById('noActiveStakesMessage')) {
                        document.getElementById('noActiveStakesMessage').classList.add('hidden'); // Ocultar mensaje si hay stakes
                    }

                    for (let i = 0; i < userStakesLength; i++) {
                        const stake = await stakingContract.getUserStake(userAddress, i);

                        // Solo mostrar stakes no retirados
                        if (!stake.withdrawn) {
                            const reward = await stakingContract.calculateReward(userAddress, i);
                            totalRewardsAccumulated = totalRewardsAccumulated.add(reward);

                            // Ajustar duración para mostrar en días, o "Flexible"
                            const durationSeconds = stake.duration.toNumber();
                            let durationText;
                            if (durationSeconds === 0) {
                                durationText = 'Flexible';
                            } else {
                                const durationDays = durationSeconds / (60 * 60 * 24); // Segundos a días
                                durationText = `${durationDays.toFixed(0)} días`;
                            }
                            
                            const startTime = new Date(stake.startTime.toNumber() * 1000).toLocaleString();
                            const endTime = durationSeconds === 0 ? 'N/A' : new Date((stake.startTime.toNumber() + durationSeconds) * 1000).toLocaleString();

                            const stakeCard = document.createElement('div');
                            stakeCard.className = 'card p-6 rounded-xl shadow-md';
                            stakeCard.innerHTML = `
                                <h4 class="text-xl font-semibold text-yellow-300">Stake ID: ${i}</h4>
                                <p>Cantidad Stakeada: <span class="font-bold">${formatUnits(stake.amount)} OROBIT</span></p>
                                <p>APR: <span class="font-bold">${(stake.aprBP.toNumber() / 100).toFixed(2)}%</span></p>
                                <p>Inicio: ${startTime}</p>
                                <p>Duración: ${durationText}</p>
                                <p>Fin: ${endTime}</p>
                                <p>Recompensa Acumulada: <span class="font-bold text-green-400">${formatUnits(reward)} OROBIT</span></p>
                            `;
                            activeStakesDiv.appendChild(stakeCard);
                        }
                    }
                     // Si después de filtrar no hay stakes activos, mostrar el mensaje
                    if (activeStakesDiv.children.length === 0) {
                        activeStakesDiv.innerHTML = '<p class="text-gray-400" id="noActiveStakesMessage">No tienes stakes activos.</p>';
                    }
                }

                totalRewardsDisplay.textContent = `${formatUnits(totalRewardsAccumulated)} OROBIT`;

            } catch (error) {
                console.error("Error al cargar datos del dashboard:", error);
                showMessage(`Error al cargar dashboard: ${error.message}`, 'error');
            }
        }

        /**
         * @dev Carga los pools de staking disponibles y los muestra en el select.
         * Esta función ahora usa 'publicProvider' para leer los pools sin necesidad de conexión de billetera.
         */
        async function loadStakingPools() {
            // Asegurarse de que publicProvider esté inicializado para leer datos del contrato
            if (!publicProvider) {
                publicProvider = new ethers.providers.JsonRpcProvider(RPC_URL);
            }
            // Usar una instancia del contrato de staking con el publicProvider para solo lectura
            const readOnlyStakingContract = new ethers.Contract(STAKING_CONTRACT_ADDRESS, STAKING_CONTRACT_ABI, publicProvider);

            try {
                const poolsLength = await readOnlyStakingContract.getStakingPoolsLength();
                stakingPoolSelect.innerHTML = ''; // Limpiar opciones existentes

                if (poolsLength == 0) {
                    stakingPoolSelect.innerHTML = '<option value="">No hay pools disponibles</option>';
                    stakeBtn.disabled = true; // El botón de stake sigue deshabilitado si no hay pools
                    approveBtn.disabled = true;
                    return;
                }

                let activePoolsExist = false;
                for (let i = 0; i < poolsLength; i++) {
                    const pool = await readOnlyStakingContract.getPool(i);
                    if (pool.isActive) {
                        activePoolsExist = true;
                        const option = document.createElement('option');
                        option.value = i;
                        const durationText = pool.isFlexible ? 'Flexible' : `${(pool.duration.toNumber() / SECONDS_IN_YEAR).toFixed(0)} días`;
                        option.textContent = `ID ${i}: ${durationText} - ${(pool.aprBP.toNumber() / 100).toFixed(2)}% APR`;
                        stakingPoolSelect.appendChild(option);
                    }
                }

                if (!activePoolsExist) {
                    stakingPoolSelect.innerHTML = '<option value="">No hay pools activos</option>';
                    stakeBtn.disabled = true;
                    approveBtn.disabled = true;
                    showMessage('No hay pools de staking activos disponibles. Contacta al administrador.', 'warning');
                } else {
                    // Si hay pools activos, los botones se habilitan SOLO si el userAddress está definido
                    stakeBtn.disabled = !userAddress;
                    approveBtn.disabled = !userAddress;
                }

            } catch (error) {
                console.error("Error al cargar pools de staking:", error);
                // Si el error es debido a que el contrato o la red no están disponibles, lo manejamos
                if (error.message.includes("could not be detected") || error.message.includes("contract not deployed")) {
                    stakingPoolSelect.innerHTML = '<option value="">Error al cargar pools (Contrato/Red)</option>';
                } else {
                    stakingPoolSelect.innerHTML = '<option value="">Error al cargar pools</option>';
                }
                showMessage(`Error al cargar pools: ${error.message}`, 'error');
                stakeBtn.disabled = true;
                approveBtn.disabled = true;
            }
        }
        
        /**
         * @dev Actualiza el balance disponible en la sección de staking.
         */
        async function updateAvailableBalance() {
            if (oroBitTokenContract && userAddress) {
                try {
                    const balance = await oroBitTokenContract.balanceOf(userAddress);
                    availableBalanceDisplay.textContent = `${formatUnits(balance)} OROBIT`;
                } catch (error) {
                    console.error("Error al actualizar el balance disponible:", error);
                    availableBalanceDisplay.textContent = `Error`;
                }
            } else {
                availableBalanceDisplay.textContent = 'Conecta tu cartera';
            }
        }

        /**
         * @dev Comprueba si la cuenta conectada tiene acceso de administrador.
         */
        async function checkAdminAccess() {
            if (!stakingContract || !userAddress) {
                adminPanel.classList.add('hidden');
                adminMessage.classList.remove('hidden');
                return;
            }
            try {
                // Usar la instancia del contrato con el signer para leer el owner
                const contractOwner = await stakingContract.owner(); 
                if (contractOwner.toLowerCase() === OWNER_ADDRESS.toLowerCase()) { // Comparar con OWNER_ADDRESS constante
                    adminPanel.classList.remove('hidden');
                    adminMessage.classList.add('hidden');
                    showMessage('¡Acceso de Administrador Concedido!', 'success');
                } else {
                    adminPanel.classList.add('hidden');
                    adminMessage.classList.remove('hidden');
                }
            } catch (error) {
                console.error("Error al verificar acceso de administrador:", error);
                adminPanel.classList.add('hidden');
                adminMessage.classList.remove('hidden');
            }
        }

        // --- Manejadores de Eventos ---

        connectWalletBtn.addEventListener('click', () => {
            if (userAddress) { // Si ya hay una dirección de usuario (conectado)
                disconnectWallet();
            } else { // Si no hay dirección de usuario (desconectado o intentando conectar)
                connectWallet();
            }
        });

        closeMessageBox.addEventListener('click', hideMessageBox);

        dashboardTab.addEventListener('click', () => showTab(dashboardContent, dashboardTab));
        stakeTab.addEventListener('click', () => showTab(stakeContent, stakeTab));
        withdrawTab.addEventListener('click', () => showTab(withdrawContent, withdrawTab));
        adminTab.addEventListener('click', () => showTab(adminContent, adminTab));

        maxStakeBtn.addEventListener('click', () => {
            if (userAddress && oroBitBalanceDisplay.textContent !== 'Conecta tu cartera') {
                stakeAmountInput.value = formatUnits(parseUnits(oroBitBalanceDisplay.textContent.replace(' OROBIT', '')));
            } else {
                showMessage('Conecta tu cartera para usar la función MAX.', 'warning');
            }
        });

        approveBtn.addEventListener('click', async () => {
            if (!signer || !oroBitTokenContract) {
                showMessage('Por favor, conecta tu billetera primero.', 'warning');
                return;
            }

            const amountToApprove = stakeAmountInput.value;
            if (!amountToApprove || parseFloat(amountToApprove) <= 0) {
                showMessage('Por favor, introduce una cantidad válida para aprobar.', 'warning');
                return;
            }

            try {
                const amountWei = parseUnits(amountToApprove);
                showMessage('Aprobando tokens... Por favor, confirma en MetaMask.', 'info');
                const tx = await oroBitTokenContract.approve(STAKING_CONTRACT_ADDRESS, amountWei);
                await tx.wait();
                showMessage('¡Aprobación exitosa!', 'success');
            } catch (error) {
                console.error("Error al aprobar tokens:", error);
                showMessage(`Error al aprobar: ${error.message}`, 'error');
            }
        });

        stakeBtn.addEventListener('click', async () => {
            if (!signer || !stakingContract) {
                showMessage('Por favor, conecta tu billetera primero.', 'warning');
                return;
            }

            const amountToStake = stakeAmountInput.value;
            const poolId = stakingPoolSelect.value;

            if (!amountToStake || parseFloat(amountToStake) <= 0) {
                showMessage('Por favor, introduce una cantidad válida para stakear.', 'warning');
                return;
            }
            if (!poolId || poolId === "") { // Asegurarse de que se haya seleccionado un pool
                showMessage('Por favor, selecciona un pool de staking.', 'warning');
                return;
            }

            try {
                const amountWei = parseUnits(amountToStake);
                showMessage('Realizando stake... Por favor, confirma en MetaMask.', 'info');
                const tx = await stakingContract.stake(poolId, amountWei);
                await tx.wait();
                showMessage('¡Stake exitoso! Tus OroBits están generando recompensas.', 'success');
                stakeAmountInput.value = '';
                loadDashboardData(); // Recargar datos del dashboard
                updateAvailableBalance(); // Actualizar balance disponible
            } catch (error) {
                console.error("Error al stakear tokens:", error);
                showMessage(`Error al stakear: ${error.message}`, 'error');
            }
        });

        calculateRewardBtn.addEventListener('click', async () => {
            if (!stakingContract || !userAddress) {
                showMessage('Por favor, conecta tu billetera y carga tus stakes.', 'warning');
                return;
            }

            const stakeId = withdrawStakeIdInput.value;
            if (stakeId === "" || parseInt(stakeId) < 0) {
                showMessage('Por favor, introduce un ID de stake válido.', 'warning');
                return;
            }

            try {
                const reward = await stakingContract.calculateReward(userAddress, parseInt(stakeId));
                calculatedRewardDisplay.textContent = `Recompensa estimada: ${formatUnits(reward)} OROBIT`;
                calculatedRewardDisplay.classList.remove('hidden');
                showMessage('Recompensa calculada con éxito.', 'info');
            } catch (error) {
                console.error("Error al calcular recompensa:", error);
                showMessage(`Error al calcular recompensa: ${error.message}`, 'error');
                calculatedRewardDisplay.classList.add('hidden');
            }
        });

        withdrawConfirmBtn.addEventListener('click', async () => {
            if (!signer || !stakingContract) {
                showMessage('Por favor, conecta tu billetera primero.', 'warning');
                return;
            }

            const stakeId = withdrawStakeIdInput.value;
            if (stakeId === "" || parseInt(stakeId) < 0) {
                showMessage('Por favor, introduce un ID de stake válido para retirar.', 'warning');
                return;
            }

            try {
                showMessage('Retirando stake y recompensas... Por favor, confirma en MetaMask.', 'info');
                const tx = await stakingContract.withdraw(parseInt(stakeId));
                await tx.wait();
                showMessage('¡Retiro exitoso! Tus fondos y recompensas han sido enviados a tu billetera.', 'success');
                withdrawStakeIdInput.value = '';
                calculatedRewardDisplay.classList.add('hidden');
                loadDashboardData(); // Recargar datos del dashboard
                updateAvailableBalance(); // Actualizar balance disponible
            } catch (error) {
                console.error("Error al retirar stake:", error);
                showMessage(`Error al retirar: ${error.message}`, 'error');
            }
        });

        // --- Admin Functions Event Listeners ---
        addPoolBtn.addEventListener('click', async () => {
            if (!signer || !stakingContract || userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) {
                showMessage('Acceso denegado. Solo el propietario puede añadir pools.', 'error');
                return;
            }
            const duration = poolDurationInput.value;
            const apr = poolAPRInput.value;
            const isFlexible = isFlexiblePoolCheckbox.checked;

            if (!duration || !apr) {
                showMessage('Por favor, completa todos los campos para añadir un pool.', 'warning');
                return;
            }

            try {
                showMessage('Añadiendo pool... Confirma en MetaMask.', 'info');
                const tx = await stakingContract.addPool(duration, apr, isFlexible);
                await tx.wait();
                showMessage('Pool añadido con éxito.', 'success');
                loadStakingPools(); // Recargar pools para actualizar la lista
                poolDurationInput.value = '';
                poolAPRInput.value = '';
                isFlexiblePoolCheckbox.checked = false;
            } catch (error) {
                console.error("Error al añadir pool:", error);
                showMessage(`Error al añadir pool: ${error.message}`, 'error');
            }
        });

        setPoolStatusBtn.addEventListener('click', async () => {
            if (!signer || !stakingContract || userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) {
                showMessage('Acceso denegado. Solo el propietario puede cambiar el estado de los pools.', 'error');
                return;
            }
            const poolId = poolIdStatusInput.value;
            const isActive = isActivePoolCheckbox.checked;

            if (poolId === "") {
                showMessage('Por favor, introduce un ID de pool.', 'warning');
                return;
            }

            try {
                showMessage('Actualizando estado del pool... Confirma en MetaMask.', 'info');
                const tx = await stakingContract.setPoolStatus(poolId, isActive);
                await tx.wait();
                showMessage(`Estado del Pool ${poolId} actualizado a ${isActive ? 'activo' : 'inactivo'}.`, 'success');
                loadStakingPools(); // Recargar pools para actualizar la lista
            } catch (error) {
                console.error("Error al actualizar estado del pool:", error);
                showMessage(`Error al actualizar estado del pool: ${error.message}`, 'error');
            }
        });

        setPenaltyBtn.addEventListener('click', async () => {
            if (!signer || !stakingContract || userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) {
                showMessage('Acceso denegado. Solo el propietario puede establecer la penalización.', 'error');
                return;
            }
            const penaltyBP = earlyWithdrawPenaltyInput.value;
            if (!penaltyBP) {
                showMessage('Por favor, introduce un valor para la penalización.', 'warning');
                return;
            }
            try {
                showMessage('Estableciendo penalización... Confirma en MetaMask.', 'info');
                const tx = await stakingContract.setEarlyWithdrawPenalty(penaltyBP);
                await tx.wait();
                showMessage('Penalización por retiro anticipado actualizada.', 'success');
            } catch (error) {
                console.error("Error al establecer penalización:", error);
                showMessage(`Error al establecer penalización: ${error.message}`, 'error');
            }
        });

        setWhaleBonusAPRBtn.addEventListener('click', async () => {
            if (!signer || !stakingContract || userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) {
                showMessage('Acceso denegado. Solo el propietario puede establecer el bonus APR.', 'error');
                return;
            }
            const bonusAPR = whaleBonusAPRInput.value;
            if (!bonusAPR) {
                showMessage('Por favor, introduce un valor para el bonus APR.', 'warning');
                return;
            }
            try {
                showMessage('Estableciendo bonus APR para ballenas... Confirma en MetaMask.', 'info');
                const tx = await stakingContract.setWhaleBonusAPR(bonusAPR);
                await tx.wait();
                showMessage('Bonus APR para ballenas actualizado.', 'success');
            } catch (error) {
                console.error("Error al establecer bonus APR:", error);
                showMessage(`Error al establecer bonus APR: ${error.message}`, 'error');
            }
        });

        setWhaleThresholdBtn.addEventListener('click', async () => {
            if (!signer || !stakingContract || userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) {
                showMessage('Acceso denegado. Solo el propietario puede establecer el umbral de ballenas.', 'error');
                return;
            }
            const threshold = whaleThresholdInput.value;
            if (!threshold) {
                showMessage('Por favor, introduce un valor para el umbral.', 'warning');
                return;
            }
            try {
                const thresholdWei = parseUnits(threshold);
                showMessage('Estableciendo umbral de ballenas... Confirma en MetaMask.', 'info');
                const tx = await stakingContract.setWhaleThreshold(thresholdWei);
                await tx.wait();
                showMessage('Umbral de ballenas actualizado.', 'success');
            } catch (error) {
                console.error("Error al establecer umbral de ballenas:", error);
                showMessage(`Error al establecer umbral: ${error.message}`, 'error');
            }
        });

        depositRewardsBtn.addEventListener('click', async () => {
            if (!signer || !stakingContract || userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) {
                showMessage('Acceso denegado. Solo el propietario puede depositar recompensas.', 'error');
                return;
            }
            const amount = rewardsAmountInput.value;
            if (!amount || parseFloat(amount) <= 0) {
                showMessage('Por favor, introduce una cantidad válida para depositar.', 'warning');
                return;
            }
            try {
                const amountWei = parseUnits(amount);
                showMessage('Depositando recompensas... Confirma en MetaMask. (Asegúrate de haber aprobado los tokens al contrato de staking previamente)', 'info');
                const tx = await stakingContract.depositRewards(amountWei);
                await tx.wait();
                showMessage('Recompensas depositadas con éxito.', 'success');
                loadDashboardData(); // Actualizar balance del contrato si se muestra
            } catch (error) {
                console.error("Error al depositar recompensas:", error);
                showMessage(`Error al depositar recompensas: ${error.message}`, 'error');
            }
        });

        setAdminWalletBtn.addEventListener('click', async () => {
            if (!signer || !stakingContract || userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) {
                showMessage('Acceso denegado. Solo el propietario puede cambiar la cartera de administración.', 'error');
                return;
            }
            const newAddress = newAdminWalletAddressInput.value;
            if (!newAddress || !ethers.utils.isAddress(newAddress)) {
                showMessage('Por favor, introduce una dirección de cartera válida.', 'warning');
                return;
            }
            try {
                showMessage('Cambiando cartera de administración... Confirma en MetaMask.', 'info');
                const tx = await stakingContract.setStakingAdminWallet(newAddress);
                await tx.wait();
                showMessage('Cartera de administración de staking actualizada.', 'success');
            } catch (error) {
                console.error("Error al cambiar cartera de admin:", error);
                showMessage(`Error al cambiar cartera de admin: ${error.message}`, 'error');
            }
        });

        emergencyWithdrawBtn.addEventListener('click', async () => {
            if (!signer || !stakingContract || userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) {
                showMessage('Acceso denegado. Solo el propietario puede realizar retiros de emergencia.', 'error');
                return;
            }
            const tokenAddress = emergencyTokenAddressInput.value;
            const amount = emergencyAmountInput.value;

            if (!tokenAddress || !ethers.utils.isAddress(tokenAddress)) {
                showMessage('Por favor, introduce una dirección de token válida.', 'warning');
                return;
            }
            if (!amount || parseFloat(amount) <= 0) {
                showMessage('Por favor, introduce una cantidad válida para retirar.', 'warning');
                return;
            }

            try {
                const amountWei = parseUnits(amount); // Asume 18 decimales para el token de emergencia si no se especifica
                showMessage('Realizando retiro de emergencia... Confirma en MetaMask.', 'info');
                const tx = await stakingContract.emergencyWithdrawToken(tokenAddress, amountWei);
                await tx.wait();
                showMessage('Retiro de emergencia exitoso.', 'success');
            } catch (error) {
                console.error("Error al retirar tokens de emergencia:", error);
                showMessage(`Error al retirar emergencia: ${error.message}`, 'error');
            }
        });

        pauseContractBtn.addEventListener('click', async () => {
            if (!signer || !stakingContract || userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) {
                showMessage('Acceso denegado. Solo el propietario puede pausar el contrato.', 'error');
                return;
            }
            try {
                showMessage('Pausando contrato... Confirma en MetaMask.', 'info');
                const tx = await stakingContract.pause();
                await tx.wait();
                showMessage('Contrato pausado con éxito. Las operaciones de stake y retiro están deshabilitadas.', 'success');
                loadStakingPools(); // Puede que los pools necesiten actualizarse si el frontend los deshabilita
            } catch (error) {
                console.error("Error al pausar contrato:", error);
                showMessage(`Error al pausar contrato: ${error.message}`, 'error');
            }
        });

        unpauseContractBtn.addEventListener('click', async () => {
            if (!signer || !stakingContract || userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) {
                showMessage('Acceso denegado. Solo el propietario puede reanudar el contrato.', 'error');
                return;
            }
            try {
                showMessage('Reanudando contrato... Confirma en MetaMask.', 'info');
                const tx = await stakingContract.unpause();
                await tx.wait();
                showMessage('Contrato reanudado con éxito. Las operaciones de stake y retiro están habilitadas.', 'success');
                loadStakingPools(); // Puede que los pools necesiten actualizarse
            } catch (error) {
                console.error("Error al reanudar contrato:", error);
                showMessage(`Error al reanudar contrato: ${error.message}`, 'error');
            }
        });

        // --- Inicialización ---
        document.addEventListener('DOMContentLoaded', async () => {
            showTab(dashboardContent, dashboardTab); // Mostrar Dashboard por defecto
            loadStakingPools(); // Cargar los pools al inicio para fines de marketing, incluso sin billetera conectada

            // Inicializar publicProvider aquí para que loadStakingPools pueda usarlo
            publicProvider = new ethers.providers.JsonRpcProvider(RPC_URL);

            if (typeof window.ethereum === 'undefined') {
                updateConnectionUI('install'); // Mostrar estado de "Instalar MetaMask" si no se detecta
                showMessage('MetaMask no detectado. Por favor, instálalo para usar la DApp.', 'warning');
                return;
            }

            try {
                const accounts = await window.ethereum.request({ method: 'eth_accounts' }); // No solicita conexión, solo devuelve si ya hay
                if (accounts.length > 0) {
                    await connectWallet(); // Si ya hay cuentas autorizadas, intentar la conexión completa
                } else {
                    updateConnectionUI('disconnected'); // Si no hay cuentas autorizadas, asegurar el estado inicial como desconectado
                }
            } catch (error) {
                console.error("Error durante la inicialización al verificar cuentas:", error);
                updateConnectionUI('disconnected'); // En caso de error, mostrar como desconectado
            } finally {
                // Asegurarse de que el messageBox esté oculto al final de la inicialización, si no hay un mensaje activo
                hideMessageBox(); 
            }
        });
    </script>
</body>
</html>
