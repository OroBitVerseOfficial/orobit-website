<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OroBitverse Staking App</title>
    <!-- Favicon de OroBit - Usando el logo de 1280x720px, que es el que tienes confirmado -->
    <link rel="icon" href="../images/orobit_logo_1280x720.png" type="image/png">

    <!-- Content Security Policy (CSP) - IMPORTANTE PARA PRODUCCIÓN -->
    <!-- Se ha actualizado para permitir Google Fonts y cdnjs.cloudflare.com -->
    <meta http-equiv="Content-Security-Policy" content="
        default-src 'self' data: https://cdn.tailwindcss.com https://cdnjs.cloudflare.com https://fonts.googleapis.com https://fonts.gstatic.com;
        script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com;
        style-src 'self' 'unsafe-inline' https://cdn.tailwindcss.com https://cdnjs.cloudflare.com https://fonts.googleapis.com;
        img-src 'self' data: https://placehold.co https://* ;
        font-src 'self' https://cdnjs.cloudflare.com https://fonts.gstatic.com;
        connect-src 'self' https://testnet.bscscan.com https://api-testnet.bscscan.com https://data-seed-prebsc-1-s1.binance.org:8545 https://bsc-testnet.public.blastapi.io https://bsc-testnet.drpc.org;
        object-src 'none';
        base-uri 'self';
    ">

    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts: Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Ethers.js CDN para interacción con Web3 - Versión 5.7.2 es la última estable de la v5. -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* bg-gray-900 oscuro */
            color: #e2e8f0; /* text-gray-200 */
        }
        .btn-primary {
            background: linear-gradient(to right, #FFD700, #FFA500); /* Dorado */
            color: #333;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(255, 215, 0, 0.4);
        }
        .btn-primary:hover {
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.7);
            transform: translateY(-2px);
        }
        .btn-secondary {
            background: linear-gradient(to right, #6366f1, #8b5cf6); /* Azul-Púrpura */
            color: white;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(99, 102, 241, 0.4);
        }
        .btn-secondary:hover {
            box-shadow: 0 0 20px rgba(99, 102, 241, 0.7);
            transform: translateY(-2px);
        }
        .tab-button.active {
            border-bottom: 3px solid #FFD700;
            color: #FFD700;
        }
        .card {
            background-color: rgba(45, 55, 72, 0.6); /* bg-gray-700 con opacidad */
            backdrop-filter: blur(5px);
            border: 1px solid rgba(74, 85, 104, 0.5); /* border-gray-600 con opacidad */
        }
        /* Animación para el logo */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        .animate-pulse-effect {
            animation: pulse 2s infinite ease-in-out;
        }
        /* Estilos para el texto de neón (OroBitverse) */
        .neon-text {
            text-shadow: 0 0 5px #8B5CF6, 0 0 10px #8B5CF6, 0 0 15px #8B5CF6, 0 0 20px #8B5CF6; /* purple-500 */
        }
        /* Message Box specific styles */
        #messageBox {
            animation: fadeIn 0.5s ease-out;
            min-width: 300px;
            text-align: center;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -60%); }
            to { opacity: 1; transform: translate(-50%, -50%); }
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #6366f1;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200 min-h-screen flex flex-col items-center">

    <!-- Header / Navbar -->
    <header class="w-full bg-gray-800 bg-opacity-70 backdrop-filter backdrop-blur-lg sticky top-0 z-50 shadow-lg py-4">
        <nav class="container mx-auto px-4 flex justify-between items-center">
            <div class="flex items-center">
                <!-- Logo con animación - Usando orobit_logo_1280x720.png -->
                <img src="../images/orobit_logo_1280x720.png" alt="OroBitverse Logo" class="h-10 mr-3 animate-pulse-effect rounded-lg">
                <!-- Enlace del logo y nombre a la página principal -->
                <a href="../index.html" class="text-2xl font-bold text-yellow-400 neon-text">OroBitverse</a>
            </div>
            <div class="flex items-center space-x-4">
                <!-- Estado de la billetera: Desconectado, Conectando..., Conectado -->
                <span id="walletAddressDisplay" class="text-gray-400 text-sm md:text-base">Desconectado</span>
                <!-- Botón de Conectar/Desconectar Cartera -->
                <button id="connectWalletBtn" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-full transition duration-300">
                    Conectar Cartera
                </button>
            </div>
        </nav>
    </header>

    <main class="container mx-auto p-4 mt-8 flex-grow">
        <!-- Message Box para alertas personalizadas -->
        <div id="messageBox" class="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 bg-yellow-400 text-gray-900 p-6 rounded-lg shadow-xl z-50 hidden" role="alert">
            <div id="messageSpinner" class="spinner hidden"></div>
            <p id="messageText" class="text-lg font-semibold"></p>
            <button id="closeMessageBox" class="mt-4 bg-gray-800 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded-full">Cerrar</button>
        </div>

        <div class="bg-gray-800 p-6 rounded-xl shadow-xl">
            <!-- Pestañas de navegación -->
            <div class="flex justify-center border-b border-gray-700 mb-6">
                <button id="dashboardTab" class="tab-button py-3 px-6 text-lg font-semibold transition duration-300 active">
                    Mi Dashboard
                </button>
                <button id="stakeTab" class="tab-button py-3 px-6 text-lg font-semibold transition duration-300">
                    Stakear
                </button>
                <button id="withdrawTab" class="tab-button py-3 px-6 text-lg font-semibold transition duration-300">
                    Retirar
                </button>
                <button id="adminTab" class="tab-button py-3 px-6 text-lg font-semibold transition duration-300">
                    Admin
                </button>
            </div>

            <!-- Contenido del Dashboard -->
            <div id="dashboardContent" class="tab-content">
                <h2 class="text-3xl font-bold text-yellow-400 mb-6 text-center">Mi Dashboard</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
                    <div class="card p-6 rounded-xl shadow-md">
                        <h3 class="text-xl font-semibold text-blue-300 mb-3">Balance OroBit</h3>
                        <p id="oroBitBalance" class="text-3xl font-bold">0.00 OROBIT</p>
                    </div>
                    <div class="card p-6 rounded-xl shadow-md">
                        <h3 class="text-xl font-semibold text-green-300 mb-3">Recompensas Totales Acumuladas</h3>
                        <p id="totalRewards" class="text-3xl font-bold">0.00 OROBIT</p>
                    </div>
                </div>

                <h3 class="text-2xl font-bold text-yellow-300 mb-4">Mis Stakes Activos</h3>
                <div id="activeStakes" class="space-y-4">
                    <!-- Los stakes activos se cargarán aquí -->
                    <p class="text-gray-400" id="noActiveStakesMessage">No tienes stakes activos.</p>
                </div>
            </div>

            <!-- Contenido de Staking -->
            <div id="stakeContent" class="tab-content hidden">
                <h2 class="text-3xl font-bold text-yellow-400 mb-6 text-center">Stakear OroBit</h2>
                <div class="card p-8 rounded-xl shadow-lg max-w-lg mx-auto">
                    <div class="mb-4">
                        <label for="stakeAmount" class="block text-gray-300 text-sm font-bold mb-2">Cantidad a Stakear (OROBIT):</label>
                        <div class="flex items-center border border-gray-600 rounded-lg overflow-hidden">
                            <input type="number" id="stakeAmount" class="shadow appearance-none border-none rounded w-full py-3 px-4 bg-gray-700 text-gray-200 leading-tight focus:outline-none focus:shadow-outline" placeholder="Ej. 1000">
                            <button id="maxStakeBtn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-4 rounded-r-lg transition duration-300">MAX</button>
                        </div>
                        <p class="text-gray-400 text-sm mt-1">Balance Disponible: <span id="availableBalance">0.00 OROBIT</span></p>
                    </div>

                    <div class="mb-6">
                        <label for="stakingPool" class="block text-gray-300 text-sm font-bold mb-2">Seleccionar Pool de Staking:</label>
                        <select id="stakingPool" class="shadow border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200 leading-tight focus:outline-none focus:shadow-outline">
                            <!-- Opciones de pools se cargarán aquí dinámicamente -->
                        </select>
                    </div>

                    <button id="approveBtn" class="w-full btn-secondary font-bold py-3 px-6 rounded-xl text-lg mb-4">
                        Aprobar OroBit
                    </button>
                    <button id="stakeBtn" class="w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">
                        Confirmar Stake
                    </button>
                </div>
            </div>

            <!-- Contenido de Retiro -->
            <div id="withdrawContent" class="tab-content hidden">
                <h2 class="text-3xl font-bold text-yellow-400 mb-6 text-center">Retirar Stake y Recompensas</h2>
                <div class="card p-8 rounded-xl shadow-lg max-w-lg mx-auto">
                    <div class="mb-4">
                        <label for="withdrawStakeId" class="block text-gray-300 text-sm font-bold mb-2">ID de tu Stake a Retirar:</label>
                        <input type="number" id="withdrawStakeId" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200 leading-tight focus:outline-none focus:shadow-outline" placeholder="Ej. 0">
                    </div>
                    <button id="calculateRewardBtn" class="w-full btn-secondary font-bold py-3 px-6 rounded-xl text-lg mb-4">
                        Calcular Recompensa
                    </button>
                    <p id="calculatedRewardDisplay" class="text-center text-lg text-green-300 mb-6 hidden">
                        Recompensa estimada: <span class="font-bold">0.00 OROBIT</span>
                    </p>
                    <button id="withdrawConfirmBtn" class="w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">
                        Retirar Stake
                    </button>
                </div>
            </div>

            <!-- Contenido de Admin (solo para el propietario) -->
            <div id="adminContent" class="tab-content hidden">
                <h2 class="text-3xl font-bold text-yellow-400 mb-6 text-center">Panel de Administración</h2>
                <p id="adminMessage" class="text-red-400 text-center mb-6 hidden">
                    Acceso restringido. Solo el propietario del contrato puede ver este panel.
                </p>

                <div id="adminPanel" class="space-y-8 hidden">
                    <!-- Sección Añadir Pool -->
                    <div class="card p-8 rounded-xl shadow-lg">
                        <h3 class="text-2xl font-bold text-blue-300 mb-4">Añadir Nuevo Pool de Staking</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div>
                                <label for="poolDuration" class="block text-gray-300 text-sm font-bold mb-2">Duración (segundos, 0 para flexible):</label>
                                <input type="number" id="poolDuration" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="Ej. 2592000 (30 días)">
                            </div>
                            <div>
                                <label for="poolAPR" class="block text-gray-300 text-sm font-bold mb-2">APR (puntos base, Ej. 500 para 5%):</label>
                                <input type="number" id="poolAPR" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="Ej. 500">
                            </div>
                        </div>
                        <div class="mt-4 flex items-center">
                            <input type="checkbox" id="isFlexiblePool" class="form-checkbox h-5 w-5 text-blue-600 rounded">
                            <label for="isFlexiblePool" class="ml-2 text-gray-300">Es Flexible</label>
                        </div>
                        <button id="addPoolBtn" class="mt-6 w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">Añadir Pool</button>
                    </div>

                    <!-- Sección Actualizar Estado de Pool -->
                    <div class="card p-8 rounded-xl shadow-lg">
                        <h3 class="text-2xl font-bold text-blue-300 mb-4">Actualizar Estado de Pool Existente</h3>
                        <div class="mb-4">
                            <label for="poolIdStatus" class="block text-gray-300 text-sm font-bold mb-2">ID del Pool:</label>
                            <input type="number" id="poolIdStatus" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="Ej. 0">
                        </div>
                        <div class="mt-4 flex items-center">
                            <input type="checkbox" id="isActivePool" class="form-checkbox h-5 w-5 text-green-600 rounded" checked>
                            <label for="isActivePool" class="ml-2 text-gray-300">Activo</label>
                        </div>
                        <button id="setPoolStatusBtn" class="mt-6 w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">Actualizar Estado</button>
                    </div>

                    <!-- Sección Actualizar Penalización Retiro Anticipado -->
                    <div class="card p-8 rounded-xl shadow-lg">
                        <h3 class="text-2xl font-bold text-blue-300 mb-4">Configuración de Penalizaciones y Bonus</h3>
                        <div class="mb-4">
                            <label for="earlyWithdrawPenalty" class="block text-gray-300 text-sm font-bold mb-2">Penalización Retiro Anticipado (puntos base, Ej. 2000 para 20%):</label>
                            <input type="number" id="earlyWithdrawPenalty" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="Ej. 2000">
                        </div>
                        <button id="setPenaltyBtn" class="mt-6 w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">Establecer Penalización</button>
                        
                        <div class="mt-6 mb-4">
                            <label for="whaleBonusAPR" class="block text-gray-300 text-sm font-bold mb-2">Bonus APR para Ballenas (puntos base, Ej. 100 para 1%):</label>
                            <input type="number" id="whaleBonusAPR" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="Ej. 100">
                        </div>
                        <button id="setWhaleBonusAPRBtn" class="mt-6 w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">Establecer Bonus APR Ballenas</button>

                        <div class="mt-6 mb-4">
                            <label for="whaleThreshold" class="block text-gray-300 text-sm font-bold mb-2">Umbral de Ballena (OROBIT, Ej. 500000):</label>
                            <input type="number" id="whaleThreshold" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="Ej. 500000">
                        </div>
                        <button id="setWhaleThresholdBtn" class="mt-6 w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">Establecer Umbral Ballenas</button>
                    </div>

                    <!-- Sección Depositar Recompensas -->
                    <div class="card p-8 rounded-xl shadow-lg">
                        <h3 class="text-2xl font-bold text-blue-300 mb-4">Depositar Recompensas</h3>
                        <div class="mb-4">
                            <label for="rewardsAmount" class="block text-gray-300 text-sm font-bold mb-2">Cantidad de OroBit a Depositar:</label>
                            <input type="number" id="rewardsAmount" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="Ej. 1000">
                        </div>
                        <button id="depositRewardsBtn" class="mt-6 w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">Depositar Recompensas</button>
                    </div>

                    <!-- Sección Cambiar Cartera de Admin -->
                    <div class="card p-8 rounded-xl shadow-lg">
                        <h3 class="text-2xl font-bold text-blue-300 mb-4">Cambiar Cartera de Administración de Staking</h3>
                        <div class="mb-4">
                            <label for="newAdminWalletAddress" class="block text-gray-300 text-sm font-bold mb-2">Nueva Dirección de Cartera:</label>
                            <input type="text" id="newAdminWalletAddress" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="0x...">
                        </div>
                        <button id="setAdminWalletBtn" class="mt-6 w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">Establecer Cartera de Admin</button>
                    </div>

                    <!-- Sección Retiro de Tokens de Emergencia -->
                    <div class="card p-8 rounded-xl shadow-lg">
                        <h3 class="text-2xl font-bold text-blue-300 mb-4">Retiro de Tokens de Emergencia</h3>
                        <div class="mb-4">
                            <label for="emergencyTokenAddress" class="block text-gray-300 text-sm font-bold mb-2">Dirección del Token (ERC20):</label>
                            <input type="text" id="emergencyTokenAddress" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="0x...">
                        </div>
                        <div class="mb-4">
                            <label for="emergencyAmount" class="block text-gray-300 text-sm font-bold mb-2">Cantidad a Retirar:</label>
                            <input type="number" id="emergencyAmount" class="shadow appearance-none border border-gray-600 rounded-lg w-full py-3 px-4 bg-gray-700 text-gray-200" placeholder="Ej. 1000">
                        </div>
                        <button id="emergencyWithdrawBtn" class="mt-6 w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg">Retirar Tokens de Emergencia</button>
                    </div>

                    <!-- Sección Pausar/Reanudar Contrato -->
                    <div class="card p-8 rounded-xl shadow-lg">
                        <h3 class="text-2xl font-bold text-blue-300 mb-4">Control de Pausa del Contrato</h3>
                        <button id="pauseContractBtn" class="mt-6 w-full btn-primary font-bold py-3 px-6 rounded-xl text-lg mb-4">Pausar Contrato</button>
                        <button id="unpauseContractBtn" class="w-full btn-secondary font-bold py-3 px-6 rounded-xl text-lg">Reanudar Contrato</button>
                    </div>

                </div>
            </div>
        </div>
    </main>

    <footer class="w-full bg-gray-800 py-6 mt-8">
        <div class="container mx-auto px-4 text-center text-gray-500 text-sm">
            <p>&copy; 2025 OroBitverse. Todos los derechos reservados.</p>
        </div>
    </footer>

    <script>
        // --- Constantes de Contrato y Red (BNB Smart Chain Testnet) ---
        const OROBIT_TOKEN_ADDRESS = "0x8bC4B9238047843C3Cb0508b9EdeB3a7729D72c3"; // Token OroBit en Testnet
        const STAKING_CONTRACT_ADDRESS = "0x8278eBAdBC25BEea94d6370174b8Eeb7b5bfD253"; // Contrato de Staking en Testnet
        const OWNER_ADDRESS = "0x0C6DA70B1BB307D78d154ec6adbD57ff696E0660"; // Dirección del propietario del contrato

        const CHAIN_ID = "0x61"; // ID de la cadena para BNB Smart Chain Testnet (97 en decimal)
        const CHAIN_NAME = "BNB Smart Chain Testnet";
        const RPC_URL = "https://data-seed-prebsc-1-s1.binance.org:8545"; // RPC URL para Ethers.js
        const BLOCK_EXPLORER_URL = "https://testnet.bscscan.com";

        const SECONDS_IN_YEAR = 31536000; // Constante para cálculos de duración (365 días * 24 horas * 60 minutos * 60 segundos)
        const BASIS_POINTS_DIVISOR = 10000; // Para convertir puntos base a porcentajes

        // --- Variables Globales de Ethers.js y Contratos ---
        let provider;
        let signer;
        let userAddress = null;
        let orobitTokenContract;
        let stakingContract;
        let tokenDecimals = 18; // Asumimos 18 decimales por defecto, se actualizará al cargar el token.

        // ABIs (Application Binary Interfaces)
        // ABI del Token OroBit (IERC20 simplificado y CORRECTO)
        const OROBIT_TOKEN_ABI = [
            // Funciones de vista
            "function name() view returns (string)",
            "function symbol() view returns (string)",
            "function decimals() view returns (uint8)",
            "function totalSupply() view returns (uint256)",
            "function balanceOf(address account) view returns (uint256)",
            "function allowance(address owner, address spender) view returns (uint256)",
            // Funciones de escritura
            "function approve(address spender, uint256 amount) returns (bool)",
            "function transfer(address to, uint256 amount) returns (bool)",
            "function transferFrom(address sender, address recipient, uint256 amount) returns (bool)",
            // Eventos
            "event Transfer(address indexed from, address indexed to, uint256 value)",
            "event Approval(address indexed owner, address indexed spender, uint256 value)"
        ];

        // ABI del Contrato de Staking (OroBitStakingVault - ABI corregido, SÓLO FUNCIONES Y EVENTOS)
        // ATENCIÓN: Si tu contrato tiene más funciones, DEBES obtener el ABI completo y limpio
        // desde la salida de compilación de tu contrato Solidity.
        const STAKING_CONTRACT_ABI = [
            // Constructor (solo para referencia, no se llama desde JS así)
            { "inputs": [{"internalType":"contract IERC20","name":"_oroBitToken","type":"address"},{"internalType":"address","name":"_stakingAdminWallet","type":"address"}], "stateMutability":"nonpayable","type":"constructor"},
            
            // Funciones de Vista (view)
            "function owner() view returns (address)",
            "function paused() view returns (bool)",
            "function calculateReward(address _user, uint256 _stakeId) view returns (uint256 reward)",
            "function getUserStakesLength(address _user) view returns (uint256)",
            "function getUserStake(address _user, uint256 _stakeId) view returns (uint256 amount, uint256 startTime, uint256 duration, uint256 aprBP, bool withdrawn, uint256 lastRewardClaimTime)",
            "function getPool(uint256 _poolId) view returns (uint256 duration, uint256 aprBP, bool isActive, bool isFlexible)",
            "function stakingPools(uint256) view returns (uint256 duration, uint256 aprBP, bool isActive, bool isFlexible)", // Para acceder a elementos específicos del array público
            "function getStakingPoolsLength() view returns (uint256)", // Asumo que existe esta función para obtener la longitud del array `stakingPools`
            "function getContractTokenBalance() view returns (uint256)", // Asumo esta función para el balance del contrato

            // Propiedades públicas de solo lectura (si el contrato las tiene)
            "function whaleBonusAPR_BP() view returns (uint256)",
            "function whaleThreshold() view returns (uint256)",
            "function earlyWithdrawPenaltyBP() view returns (uint256)",
            "function stakingAdminWallet() view returns (address)",


            // Funciones de Escritura (nonpayable/payable)
            "function pause()",
            "function unpause()",
            "function addPool(uint256 _duration, uint256 _aprBP, bool _isFlexible)",
            "function setPoolStatus(uint256 _poolId, bool _isActive)",
            "function setWhaleBonusAPR(uint256 _newAPR_BP)",
            "function setWhaleThreshold(uint256 _newThreshold)",
            "function setEarlyWithdrawPenalty(uint256 _newPenaltyBP)",
            "function setStakingAdminWallet(address _newAdminWallet)",
            "function depositRewards(uint256 _amount)",
            "function emergencyWithdrawToken(address _tokenAddress, uint256 _amount)",
            "function stake(uint256 _poolId, uint256 _amount)",
            "function withdraw(uint256 _stakeId)",
            
            // Eventos (importante para que ethers.js los detecte si se necesita escuchar)
            "event Paused(address account)",
            "event Unpaused(address account)",
            "event PoolAdded(uint256 poolId, uint256 duration, uint256 aprBP, bool isFlexible)",
            "event PoolStatusUpdated(uint256 poolId, bool isActive)",
            "event WhaleBonusAPRUpdated(uint256 newAPR_BP)",
            "event WhaleThresholdUpdated(uint256 newThreshold)",
            "event EarlyWithdrawPenaltyUpdated(uint256 newPenaltyBP)",
            "event StakingAdminWalletUpdated(address indexed oldAddress, address indexed newAddress)",
            "event RewardsDeposited(address indexed depositor, uint256 amount)",
            "event EmergencyTokensWithdrawn(address indexed tokenAddress, address indexed ownerAddress, uint256 amount)",
            "event Staked(address indexed user, uint256 amount, uint256 poolId, uint256 stakeId)",
            "event Withdrawn(address indexed user, uint256 stakeId, uint256 principalAmount, uint256 rewardedAmount, uint256 penaltyAmount, bool earlyWithdrawal)"
        ];

        // --- Funciones de Utilidad de UI (Message Box) ---
        function showMessageBox(message, type = 'info', spinner = false) {
            const msgBox = document.getElementById('messageBox');
            const msgText = document.getElementById('messageText');
            const spinnerElem = document.getElementById('messageSpinner');

            msgText.textContent = message;
            msgBox.className = 'fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 p-6 rounded-lg shadow-xl z-50'; // Reset classes
            
            if (type === 'info') {
                msgBox.classList.add('bg-blue-400', 'text-gray-900');
            } else if (type === 'success') {
                msgBox.classList.add('bg-green-400', 'text-gray-900');
            } else if (type === 'error') {
                msgBox.classList.add('bg-red-500', 'text-white');
            } else if (type === 'warning') {
                msgBox.classList.add('bg-yellow-400', 'text-gray-900');
            }

            if (spinner) {
                spinnerElem.classList.remove('hidden');
                document.getElementById('closeMessageBox').classList.add('hidden'); // Hide close button when spinning
            } else {
                spinnerElem.classList.add('hidden');
                document.getElementById('closeMessageBox').classList.remove('hidden');
            }

            msgBox.classList.remove('hidden');
            return new Promise(resolve => {
                document.getElementById('closeMessageBox').onclick = () => {
                    msgBox.classList.add('hidden');
                    resolve(true); // Resolve when closed
                };
            });
        }

        function hideMessageBox() {
            document.getElementById('messageBox').classList.add('hidden');
            document.getElementById('messageSpinner').classList.add('hidden');
        }

        // --- Conexión a Cartera y Ethers.js ---
        async function connectWallet() {
            if (window.ethereum) {
                try {
                    provider = new ethers.providers.Web3Provider(window.ethereum);
                    // Request access to the user's accounts
                    await provider.send("eth_requestAccounts", []);
                    signer = provider.getSigner();
                    userAddress = await signer.getAddress();

                    // Check if the connected chain is BSC Testnet
                    const network = await provider.getNetwork();
                    if (network.chainId !== parseInt(CHAIN_ID, 16)) {
                        try {
                            // Attempt to switch to BSC Testnet
                            await window.ethereum.request({
                                method: 'wallet_switchEthereumChain',
                                params: [{ chainId: CHAIN_ID }],
                            });
                            // After switch, re-initialize
                            provider = new ethers.providers.Web3Provider(window.ethereum);
                            signer = provider.getSigner();
                            userAddress = await signer.getAddress();
                        } catch (switchError) {
                            // This error means the user rejected the switch
                            if (switchError.code === 4902 || switchError.code === 4001) { // 4902 for "unrecognized chain ID", 4001 for "user rejected"
                                await showMessageBox(`Por favor, cambia a ${CHAIN_NAME} en MetaMask o añade la red manualmente.`, 'error');
                            } else {
                                await showMessageBox(`Error al cambiar de red: ${switchError.message}`, 'error');
                            }
                            // Reset state if switch failed
                            userAddress = null;
                            updateWalletUI();
                            return;
                        }
                    }

                    // Initialize contract instances
                    orobitTokenContract = new ethers.Contract(OROBIT_TOKEN_ADDRESS, OROBIT_TOKEN_ABI, signer);
                    stakingContract = new ethers.Contract(STAKING_CONTRACT_ADDRESS, STAKING_CONTRACT_ABI, signer);

                    // Fetch decimals once
                    try {
                        tokenDecimals = await orobitTokenContract.decimals();
                    } catch (e) {
                        console.warn("Could not fetch token decimals, defaulting to 18.", e);
                        tokenDecimals = 18; // Fallback
                    }

                    updateWalletUI();
                    await updateDashboardData();
                    await renderStakingPools(); // Refresh pools based on contract
                    await renderMyStakes(); // Refresh user stakes

                    // Listen for account/chain changes
                    window.ethereum.on('accountsChanged', handleAccountsChanged);
                    window.ethereum.on('chainChanged', handleChainChanged);

                } catch (error) {
                    console.error("Error al conectar la cartera:", error);
                    userAddress = null; // Reset
                    updateWalletUI();
                    await showMessageBox(`Error al conectar la cartera: ${error.message}. Asegúrate de que MetaMask esté instalado y desbloqueado.`, 'error');
                }
            } else {
                await showMessageBox("MetaMask no detectado. Por favor, instala MetaMask para usar esta DApp.", 'warning');
            }
        }

        async function disconnectWallet() {
            userAddress = null;
            orobitTokenContract = null;
            stakingContract = null;
            updateWalletUI();
            document.getElementById('oroBitBalance').textContent = '0.00 OROBIT';
            document.getElementById('totalRewards').textContent = '0.00 OROBIT';
            document.getElementById('availableBalance').textContent = '0.00 OROBIT';
            document.getElementById('activeStakes').innerHTML = '<p class="text-gray-400" id="noActiveStakesMessage">No tienes stakes activos.</p>';
            document.getElementById('stakingPool').innerHTML = ''; // Clear pools
            document.getElementById('adminPanel').classList.add('hidden'); // Hide admin panel
            document.getElementById('adminMessage').classList.remove('hidden'); // Show admin message
            await showMessageBox("Cartera desconectada.", 'info');
        }

        function updateWalletUI() {
            const connectBtn = document.getElementById('connectWalletBtn');
            const walletDisplay = document.getElementById('walletAddressDisplay');
            if (userAddress) {
                walletDisplay.textContent = `Conectado: ${userAddress.substring(0, 6)}...${userAddress.substring(userAddress.length - 4)}`;
                connectBtn.textContent = 'Desconectar Cartera';
                connectBtn.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                connectBtn.classList.add('bg-red-600', 'hover:bg-red-700');
            } else {
                walletDisplay.textContent = 'Desconectado';
                connectBtn.textContent = 'Conectar Cartera';
                connectBtn.classList.remove('bg-red-600', 'hover:bg-red-700');
                connectBtn.classList.add('bg-blue-600', 'hover:bg-blue-700');
            }
        }

        // Event handlers for MetaMask
        async function handleAccountsChanged(accounts) {
            if (accounts.length === 0) {
                console.log('Por favor, conecta a MetaMask.');
                disconnectWallet();
            } else if (accounts[0] !== userAddress) {
                userAddress = accounts[0];
                console.log(`Cuenta cambiada a: ${userAddress}`);
                updateWalletUI();
                await updateDashboardData();
                await renderMyStakes();
            }
        }

        async function handleChainChanged(chainId) {
            console.log(`Cambio de red a Chain ID: ${chainId}`);
            // Recargar la página o re-inicializar el proveedor y los contratos
            window.location.reload(); 
        }

        // --- Funciones de Interacción con Contratos ---

        // Actualizar datos del Dashboard
        async function updateDashboardData() {
            if (!orobitTokenContract || !userAddress) {
                document.getElementById('oroBitBalance').textContent = '0.00 OROBIT';
                document.getElementById('availableBalance').textContent = '0.00 OROBIT';
                document.getElementById('totalRewards').textContent = '0.00 OROBIT';
                return;
            }

            try {
                // Balance de OroBit
                const balanceWei = await orobitTokenContract.balanceOf(userAddress);
                document.getElementById('oroBitBalance').textContent = `${ethers.utils.formatUnits(balanceWei, tokenDecimals)} OROBIT`;
                document.getElementById('availableBalance').textContent = `${ethers.utils.formatUnits(balanceWei, tokenDecimals)} OROBIT`;

                // Total de recompensas acumuladas (sumar de todos los stakes)
                let totalAccruedRewards = ethers.BigNumber.from(0);
                const userStakesLength = await stakingContract.getUserStakesLength(userAddress);
                for (let i = 0; i < userStakesLength; i++) {
                    const stake = await stakingContract.getUserStake(userAddress, i);
                    if (!stake.withdrawn) { // Solo contar si no ha sido retirado
                        const reward = await stakingContract.calculateReward(userAddress, i);
                        totalAccruedRewards = totalAccruedRewards.add(reward);
                    }
                }
                document.getElementById('totalRewards').textContent = `${ethers.utils.formatUnits(totalAccruedRewards, tokenDecimals)} OROBIT`;

                // Admin panel visibility
                if (userAddress.toLowerCase() === OWNER_ADDRESS.toLowerCase()) {
                    document.getElementById('adminPanel').classList.remove('hidden');
                    document.getElementById('adminMessage').classList.add('hidden');
                } else {
                    document.getElementById('adminPanel').classList.add('hidden');
                    document.getElementById('adminMessage').classList.remove('hidden');
                }

            } catch (error) {
                console.error("Error al actualizar datos del dashboard:", error);
                document.getElementById('oroBitBalance').textContent = 'Error';
                document.getElementById('availableBalance').textContent = 'Error';
                document.getElementById('totalRewards').textContent = 'Error';
            }
        }

        // Renderizar los pools de staking en la pestaña "Stakear"
        async function renderStakingPools() {
            const selectElement = document.getElementById('stakingPool');
            selectElement.innerHTML = '<option value="">Cargando pools...</option>'; // Limpiar y mostrar cargando

            if (!stakingContract) {
                selectElement.innerHTML = '<option value="">Error: Contrato de Staking no inicializado.</option>';
                return;
            }

            try {
                const poolsLength = await stakingContract.getStakingPoolsLength();
                let optionsHtml = '<option value="">Selecciona un Pool</option>';
                if (poolsLength == 0) {
                     optionsHtml = '<option value="">No hay pools disponibles</option>';
                } else {
                    for (let i = 0; i < poolsLength; i++) {
                        const pool = await stakingContract.stakingPools(i); // Accede directamente a `stakingPools` por índice
                        if (pool.isActive) {
                            const durationText = pool.isFlexible ? "Flexible" : `${pool.duration / (24 * 60 * 60)} Días`;
                            const aprText = (pool.aprBP / BASIS_POINTS_DIVISOR * 100).toFixed(2); // Convertir puntos base a %
                            optionsHtml += `<option value="${i}">Pool ${durationText} - ${aprText}% APR</option>`;
                        }
                    }
                }
                selectElement.innerHTML = optionsHtml;
            } catch (error) {
                console.error("Error al cargar los pools de staking:", error);
                selectElement.innerHTML = '<option value="">Error al cargar pools</option>';
            }
        }

        // Renderizar los stakes del usuario en el Dashboard
        async function renderMyStakes() {
            const container = document.getElementById('activeStakes');
            container.innerHTML = '<p class="text-gray-400" id="noActiveStakesMessage">Cargando tus stakes...</p>'; // Clear and show loading

            if (!stakingContract || !userAddress) {
                container.innerHTML = '<p class="text-gray-400" id="noActiveStakesMessage">Conecta tu cartera para ver tus stakes.</p>';
                return;
            }

            try {
                const userStakesLength = await stakingContract.getUserStakesLength(userAddress);
                let stakesHtml = '';
                let hasActiveStakes = false;

                if (userStakesLength === 0) {
                    stakesHtml = '<p class="text-gray-400" id="noActiveStakesMessage">No tienes stakes activos.</p>';
                } else {
                    for (let i = 0; i < userStakesLength; i++) {
                        const stake = await stakingContract.getUserStake(userAddress, i);
                        if (!stake.withdrawn) {
                            hasActiveStakes = true;
                            const pool = await stakingContract.stakingPools(stake.poolId);
                            const currentReward = await stakingContract.calculateReward(userAddress, i);
                            
                            const stakedAmountFormatted = ethers.utils.formatUnits(stake.amount, tokenDecimals);
                            const rewardAmountFormatted = ethers.utils.formatUnits(currentReward, tokenDecimals);
                            
                            const durationText = pool.isFlexible ? "Flexible" : `${stake.duration / (24 * 60 * 60)} Días`;
                            const aprText = (stake.aprBP / BASIS_POINTS_DIVISOR * 100).toFixed(2);

                            const endTime = new Date((parseInt(stake.startTime) + parseInt(stake.duration)) * 1000);
                            const now = new Date();
                            const isEnded = pool.isFlexible ? false : (now > endTime);
                            const statusText = isEnded ? 'Finalizado' : 'Activo';
                            const statusColor = isEnded ? 'text-green-400' : 'text-orange-400';

                            stakesHtml += `
                                <div class="card p-4 rounded-xl shadow-md">
                                    <h3 class="text-xl font-semibold mb-2">Stake ID: ${i} | Pool: ${durationText}</h3>
                                    <p class="text-gray-300">Cantidad Staked: <span class="font-bold">${parseFloat(stakedAmountFormatted).toFixed(4)} OROBIT</span></p>
                                    <p class="text-gray-300">APR: <span class="font-bold">${aprText}%</span></p>
                                    <p class="text-gray-300">Recompensas Acumuladas: <span class="font-bold text-green-300">${parseFloat(rewardAmountFormatted).toFixed(4)} OROBIT</span></p>
                                    <p class="text-gray-300">Estado: <span class="font-bold ${statusColor}">${statusText}</span></p>
                                    <p class="text-gray-300">Inicio: ${new Date(parseInt(stake.startTime) * 1000).toLocaleDateString()}</p>
                                    ${pool.isFlexible ? '' : `<p class="text-gray-300">Fin: ${endTime.toLocaleDateString()}</p>`}
                                </div>
                            `;
                        }
                    }
                }
                container.innerHTML = stakesHtml;
                if (!hasActiveStakes && userStakesLength > 0) { // If all stakes are withdrawn
                    container.innerHTML = '<p class="text-gray-400" id="noActiveStakesMessage">No tienes stakes activos.</p>';
                }
            } catch (error) {
                console.error("Error al cargar mis stakes:", error);
                container.innerHTML = '<p class="text-red-400" id="noActiveStakesMessage">Error al cargar tus stakes. Asegúrate de estar conectado a la red correcta y que el ABI sea exacto.</p>';
            }
        }

        // --- Funciones de Staking y Retiro ---

        document.getElementById('maxStakeBtn').addEventListener('click', async () => {
            if (!orobitTokenContract || !userAddress) {
                await showMessageBox("Por favor, conecta tu cartera primero.", 'warning');
                return;
            }
            try {
                const balanceWei = await orobitTokenContract.balanceOf(userAddress);
                const balanceFormatted = ethers.utils.formatUnits(balanceWei, tokenDecimals);
                document.getElementById('stakeAmount').value = parseFloat(balanceFormatted).toFixed(4);
            } catch (error) {
                console.error("Error al obtener el balance MAX:", error);
                await showMessageBox("No se pudo obtener el balance máximo.", 'error');
            }
        });

        document.getElementById('approveBtn').addEventListener('click', async () => {
            if (!userAddress || !orobitTokenContract) {
                await showMessageBox("Por favor, conecta tu cartera y asegúrate de que el token OroBit esté inicializado.", 'warning');
                return;
            }
            const amountInput = document.getElementById('stakeAmount');
            let amount = parseFloat(amountInput.value);

            if (isNaN(amount) || amount <= 0) {
                await showMessageBox("Introduce una cantidad válida y positiva para aprobar.", 'warning');
                return;
            }
            
            const amountWei = ethers.utils.parseUnits(amount.toString(), tokenDecimals);

            try {
                await showMessageBox(`Aprobando ${amount} OROBIT para el contrato de staking...`, 'info', true);
                const tx = await orobitTokenContract.approve(STAKING_CONTRACT_ADDRESS, amountWei);
                await tx.wait(); // Esperar a que la transacción sea minada
                await showMessageBox(`Aprobación exitosa. Hash de Tx: <a href="${BLOCK_EXPLORER_URL}/tx/${tx.hash}" target="_blank">${tx.hash.substring(0, 10)}...</a>`, 'success');
            } catch (error) {
                console.error("Error al aprobar tokens:", error);
                await showMessageBox(`Error al aprobar tokens: ${error.message}`, 'error');
            } finally {
                hideMessageBox();
            }
        });

        document.getElementById('stakeBtn').addEventListener('click', async () => {
            if (!userAddress || !stakingContract || !orobitTokenContract) {
                await showMessageBox("Por favor, conecta tu cartera y asegúrate de que los contratos estén inicializados.", 'warning');
                return;
            }
            const stakeAmountInput = document.getElementById('stakeAmount');
            const poolSelect = document.getElementById('stakingPool');

            const amount = parseFloat(stakeAmountInput.value);
            const poolId = parseInt(poolSelect.value);

            if (isNaN(amount) || amount <= 0) {
                await showMessageBox("Introduce una cantidad válida para stakear.", 'warning');
                return;
            }
            if (isNaN(poolId) || poolSelect.value === "") {
                await showMessageBox("Selecciona un pool de staking válido.", 'warning');
                return;
            }
            
            const amountWei = ethers.utils.parseUnits(amount.toString(), tokenDecimals);

            try {
                // Verificar aprobación antes de stakear
                const allowance = await orobitTokenContract.allowance(userAddress, STAKING_CONTRACT_ADDRESS);
                if (allowance.lt(amountWei)) {
                    await showMessageBox("Necesitas aprobar el contrato de staking para gastar esta cantidad de OroBit primero.", 'warning');
                    return;
                }

                await showMessageBox(`Confirmando stake de ${amount} OROBIT en el Pool ID ${poolId}...`, 'info', true);
                const tx = await stakingContract.stake(poolId, amountWei);
                await tx.wait();
                await showMessageBox(`¡Stake exitoso! Hash de Tx: <a href="${BLOCK_EXPLORER_URL}/tx/${tx.hash}" target="_blank">${tx.hash.substring(0, 10)}...</a>`, 'success');
                
                stakeAmountInput.value = ''; // Limpiar input
                await updateDashboardData();
                await renderMyStakes(); // Refresh user stakes
            } catch (error) {
                console.error("Error al stakear:", error);
                await showMessageBox(`Error al stakear: ${error.message}. Asegúrate de tener suficientes tokens y BNB para gas.`, 'error');
            } finally {
                hideMessageBox();
            }
        });

        document.getElementById('calculateRewardBtn').addEventListener('click', async () => {
            if (!userAddress || !stakingContract) {
                await showMessageBox("Por favor, conecta tu cartera primero.", 'warning');
                return;
            }
            const stakeId = parseInt(document.getElementById('withdrawStakeId').value);
            if (isNaN(stakeId)) {
                await showMessageBox("Introduce un ID de stake válido.", 'warning');
                return;
            }

            try {
                await showMessageBox("Calculando recompensa...", 'info', true);
                const rewardWei = await stakingContract.calculateReward(userAddress, stakeId);
                const rewardFormatted = ethers.utils.formatUnits(rewardWei, tokenDecimals);
                
                document.getElementById('calculatedRewardDisplay').innerHTML = `Recompensa estimada: <span class="font-bold">${parseFloat(rewardFormatted).toFixed(4)} OROBIT</span>`;
                document.getElementById('calculatedRewardDisplay').classList.remove('hidden');
                await showMessageBox("Cálculo de recompensa completado.", 'success');
            } catch (error) {
                console.error("Error al calcular recompensa:", error);
                document.getElementById('calculatedRewardDisplay').classList.add('hidden');
                await showMessageBox(`Error al calcular recompensa: ${error.message}.`, 'error');
            } finally {
                hideMessageBox();
            }
        });

        document.getElementById('withdrawConfirmBtn').addEventListener('click', async () => {
            if (!userAddress || !stakingContract) {
                await showMessageBox("Por favor, conecta tu cartera primero.", 'warning');
                return;
            }
            const stakeId = parseInt(document.getElementById('withdrawStakeId').value);
            if (isNaN(stakeId)) {
                await showMessageBox("Introduce un ID de stake válido.", 'warning');
                return;
            }

            try {
                await showMessageBox(`Confirmando retiro del Stake ID ${stakeId}...`, 'info', true);
                const tx = await stakingContract.withdraw(stakeId);
                await tx.wait();
                await showMessageBox(`¡Retiro exitoso del Stake ID ${stakeId}! Hash de Tx: <a href="${BLOCK_EXPLORER_URL}/tx/${tx.hash}" target="_blank">${tx.hash.substring(0, 10)}...</a>`, 'success');
                
                document.getElementById('withdrawStakeId').value = ''; // Limpiar input
                document.getElementById('calculatedRewardDisplay').classList.add('hidden');
                await updateDashboardData();
                await renderMyStakes(); // Refresh user stakes
            } catch (error) {
                console.error("Error al retirar stake:", error);
                await showMessageBox(`Error al retirar stake: ${error.message}.`, 'error');
            } finally {
                hideMessageBox();
            }
        });

        // --- Funciones de Administración --- (Solo visibles/accesibles para el propietario del contrato)

        async function checkAdminAccess() {
            if (userAddress && userAddress.toLowerCase() === OWNER_ADDRESS.toLowerCase()) {
                document.getElementById('adminPanel').classList.remove('hidden');
                document.getElementById('adminMessage').classList.add('hidden');
            } else {
                document.getElementById('adminPanel').classList.add('hidden');
                document.getElementById('adminMessage').classList.remove('hidden');
            }
        }
        
        document.getElementById('addPoolBtn').addEventListener('click', async () => {
            if (userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) { await showMessageBox("Acceso denegado. No eres el propietario del contrato.", 'error'); return; }
            if (!stakingContract) { await showMessageBox("Contrato de Staking no inicializado.", 'warning'); return; }

            const duration = parseInt(document.getElementById('poolDuration').value);
            const apr = parseInt(document.getElementById('poolAPR').value);
            const isFlexible = document.getElementById('isFlexiblePool').checked;

            if (isNaN(duration) || isNaN(apr)) { await showMessageBox("Introduce valores válidos para duración y APR.", 'warning'); return; }

            try {
                await showMessageBox("Añadiendo nuevo pool de staking...", 'info', true);
                const tx = await stakingContract.addPool(duration, apr, isFlexible);
                await tx.wait();
                await showMessageBox(`Pool añadido exitosamente. Hash de Tx: <a href="${BLOCK_EXPLORER_URL}/tx/${tx.hash}" target="_blank">${tx.hash.substring(0, 10)}...</a>`, 'success');
                await renderStakingPools(); // Refresh pools in select dropdown
            } catch (error) {
                console.error("Error al añadir pool:", error);
                await showMessageBox(`Error al añadir pool: ${error.message}.`, 'error');
            } finally { hideMessageBox(); }
        });

        document.getElementById('setPoolStatusBtn').addEventListener('click', async () => {
            if (userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) { await showMessageBox("Acceso denegado. No eres el propietario del contrato.", 'error'); return; }
            if (!stakingContract) { await showMessageBox("Contrato de Staking no inicializado.", 'warning'); return; }

            const poolId = parseInt(document.getElementById('poolIdStatus').value);
            const isActive = document.getElementById('isActivePool').checked;

            if (isNaN(poolId)) { await showMessageBox("Introduce un ID de pool válido.", 'warning'); return; }

            try {
                await showMessageBox(`Actualizando estado del pool ${poolId} a ${isActive ? 'Activo' : 'Inactivo'}...`, 'info', true);
                const tx = await stakingContract.setPoolStatus(poolId, isActive);
                await tx.wait();
                await showMessageBox(`Estado del Pool ${poolId} actualizado. Hash de Tx: <a href="${BLOCK_EXPLORER_URL}/tx/${tx.hash}" target="_blank">${tx.hash.substring(0, 10)}...</a>`, 'success');
                await renderStakingPools(); // Refresh pools
            } catch (error) {
                console.error("Error al actualizar estado del pool:", error);
                await showMessageBox(`Error al actualizar estado del pool: ${error.message}.`, 'error');
            } finally { hideMessageBox(); }
        });

        document.getElementById('setPenaltyBtn').addEventListener('click', async () => {
            if (userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) { await showMessageBox("Acceso denegado. No eres el propietario del contrato.", 'error'); return; }
            if (!stakingContract) { await showMessageBox("Contrato de Staking no inicializado.", 'warning'); return; }

            const penalty = parseInt(document.getElementById('earlyWithdrawPenalty').value);
            if (isNaN(penalty)) { await showMessageBox("Introduce un valor válido para la penalización.", 'warning'); return; }

            try {
                await showMessageBox(`Estableciendo penalización por retiro anticipado a ${penalty} puntos base...`, 'info', true);
                const tx = await stakingContract.setEarlyWithdrawPenalty(penalty);
                await tx.wait();
                await showMessageBox(`Penalización establecida. Hash de Tx: <a href="${BLOCK_EXPLORER_URL}/tx/${tx.hash}" target="_blank">${tx.hash.substring(0, 10)}...</a>`, 'success');
            } catch (error) {
                console.error("Error al establecer penalización:", error);
                await showMessageBox(`Error al establecer penalización: ${error.message}.`, 'error');
            } finally { hideMessageBox(); }
        });

        document.getElementById('setWhaleBonusAPRBtn').addEventListener('click', async () => {
            if (userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) { await showMessageBox("Acceso denegado. No eres el propietario del contrato.", 'error'); return; }
            if (!stakingContract) { await showMessageBox("Contrato de Staking no inicializado.", 'warning'); return; }

            const bonusApr = parseInt(document.getElementById('whaleBonusAPR').value);
            if (isNaN(bonusApr)) { await showMessageBox("Introduce un valor válido para el bonus APR.", 'warning'); return; }

            try {
                await showMessageBox(`Estableciendo bonus APR para ballenas a ${bonusApr} puntos base...`, 'info', true);
                const tx = await stakingContract.setWhaleBonusAPR(bonusApr);
                await tx.wait();
                await showMessageBox(`Bonus APR para ballenas establecido. Hash de Tx: <a href="${BLOCK_EXPLORER_URL}/tx/${tx.hash}" target="_blank">${tx.hash.substring(0, 10)}...</a>`, 'success');
            } catch (error) {
                console.error("Error al establecer bonus APR de ballenas:", error);
                await showMessageBox(`Error al establecer bonus APR de ballenas: ${error.message}.`, 'error');
            } finally { hideMessageBox(); }
        });

        document.getElementById('setWhaleThresholdBtn').addEventListener('click', async () => {
            if (userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) { await showMessageBox("Acceso denegado. No eres el propietario del contrato.", 'error'); return; }
            if (!stakingContract) { await showMessageBox("Contrato de Staking no inicializado.", 'warning'); return; }

            const threshold = parseFloat(document.getElementById('whaleThreshold').value);
            if (isNaN(threshold) || threshold <= 0) { await showMessageBox("Introduce un umbral válido (>0).", 'warning'); return; }
            
            const thresholdWei = ethers.utils.parseUnits(threshold.toString(), tokenDecimals);

            try {
                await showMessageBox(`Estableciendo umbral de ballenas a ${threshold} OROBIT...`, 'info', true);
                const tx = await stakingContract.setWhaleThreshold(thresholdWei);
                await tx.wait();
                await showMessageBox(`Umbral de ballenas establecido. Hash de Tx: <a href="${BLOCK_EXPLORER_URL}/tx/${tx.hash}" target="_blank">${tx.hash.substring(0, 10)}...</a>`, 'success');
            } catch (error) {
                console.error("Error al establecer umbral de ballenas:", error);
                await showMessageBox(`Error al establecer umbral de ballenas: ${error.message}.`, 'error');
            } finally { hideMessageBox(); }
        });

        document.getElementById('depositRewardsBtn').addEventListener('click', async () => {
            if (userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) { await showMessageBox("Acceso denegado. No eres el propietario del contrato.", 'error'); return; }
            if (!stakingContract || !orobitTokenContract) { await showMessageBox("Contratos no inicializados.", 'warning'); return; }

            const amount = parseFloat(document.getElementById('rewardsAmount').value);
            if (isNaN(amount) || amount <= 0) { await showMessageBox("Introduce una cantidad válida (>0) para depositar recompensas.", 'warning'); return; }
            
            const amountWei = ethers.utils.parseUnits(amount.toString(), tokenDecimals);

            try {
                // Primero, aprobar los tokens al contrato de staking
                await showMessageBox(`Aprobando ${amount} OROBIT para el depósito de recompensas...`, 'info', true);
                let approveTx = await orobitTokenContract.approve(STAKING_CONTRACT_ADDRESS, amountWei);
                await approveTx.wait();
                await showMessageBox("Aprobación de recompensas exitosa. Ahora depositando...", 'info', true);

                // Luego, depositar las recompensas
                const tx = await stakingContract.depositRewards(amountWei);
                await tx.wait();
                await showMessageBox(`Recompensas depositadas exitosamente. Hash de Tx: <a href="${BLOCK_EXPLORER_URL}/tx/${tx.hash}" target="_blank">${tx.hash.substring(0, 10)}...</a>`, 'success');
            } catch (error) {
                console.error("Error al depositar recompensas:", error);
                await showMessageBox(`Error al depositar recompensas: ${error.message}.`, 'error');
            } finally { hideMessageBox(); }
        });

        document.getElementById('setAdminWalletBtn').addEventListener('click', async () => {
            if (userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) { await showMessageBox("Acceso denegado. No eres el propietario del contrato.", 'error'); return; }
            if (!stakingContract) { await showMessageBox("Contrato de Staking no inicializado.", 'warning'); return; }

            const newAdmin = document.getElementById('newAdminWalletAddress').value;
            if (!ethers.utils.isAddress(newAdmin)) { await showMessageBox("Introduce una dirección de cartera válida.", 'warning'); return; }

            try {
                await showMessageBox(`Cambiando cartera de administración a ${newAdmin}...`, 'info', true);
                const tx = await stakingContract.setStakingAdminWallet(newAdmin);
                await tx.wait();
                await showMessageBox(`Cartera de administración cambiada. Hash de Tx: <a href="${BLOCK_EXPLORER_URL}/tx/${tx.hash}" target="_blank">${tx.hash.substring(0, 10)}...</a>`, 'success');
            } catch (error) {
                console.error("Error al cambiar cartera de admin:", error);
                await showMessageBox(`Error al cambiar cartera de admin: ${error.message}.`, 'error');
            } finally { hideMessageBox(); }
        });

        document.getElementById('emergencyWithdrawBtn').addEventListener('click', async () => {
            if (userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) { await showMessageBox("Acceso denegado. No eres el propietario del contrato.", 'error'); return; }
            if (!stakingContract) { await showMessageBox("Contrato de Staking no inicializado.", 'warning'); return; }

            const tokenAddress = document.getElementById('emergencyTokenAddress').value;
            const amount = parseFloat(document.getElementById('emergencyAmount').value);

            if (!ethers.utils.isAddress(tokenAddress) || isNaN(amount) || amount <= 0) {
                await showMessageBox("Introduce una dirección de token válida y una cantidad válida (>0).", 'warning');
                return;
            }
            
            // Asumimos 18 decimales para el token de emergencia si no se conoce su ABI
            const amountWei = ethers.utils.parseUnits(amount.toString(), 18); // Fallback to 18 decimals

            try {
                await showMessageBox(`Retirando ${amount} tokens de emergencia de ${tokenAddress}...`, 'info', true);
                const tx = await stakingContract.emergencyWithdrawToken(tokenAddress, amountWei);
                await tx.wait();
                await showMessageBox(`Retiro de emergencia exitoso. Hash de Tx: <a href="${BLOCK_EXPLORER_URL}/tx/${tx.hash}" target="_blank">${tx.hash.substring(0, 10)}...</a>`, 'success');
            } catch (error) {
                console.error("Error al retirar tokens de emergencia:", error);
                await showMessageBox(`Error al retirar tokens de emergencia: ${error.message}.`, 'error');
            } finally { hideMessageBox(); }
        });

        document.getElementById('pauseContractBtn').addEventListener('click', async () => {
            if (userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) { await showMessageBox("Acceso denegado. No eres el propietario del contrato.", 'error'); return; }
            if (!stakingContract) { await showMessageBox("Contrato de Staking no inicializado.", 'warning'); return; }
            try {
                await showMessageBox("Pausando el contrato...", 'info', true);
                const tx = await stakingContract.pause();
                await tx.wait();
                await showMessageBox(`Contrato pausado. Hash de Tx: <a href="${BLOCK_EXPLORER_URL}/tx/${tx.hash}" target="_blank">${tx.hash.substring(0, 10)}...</a>`, 'success');
            } catch (error) {
                console.error("Error al pausar contrato:", error);
                await showMessageBox(`Error al pausar contrato: ${error.message}.`, 'error');
            } finally { hideMessageBox(); }
        });

        document.getElementById('unpauseContractBtn').addEventListener('click', async () => {
            if (userAddress.toLowerCase() !== OWNER_ADDRESS.toLowerCase()) { await showMessageBox("Acceso denegado. No eres el propietario del contrato.", 'error'); return; }
            if (!stakingContract) { await showMessageBox("Contrato de Staking no inicializado.", 'warning'); return; }
            try {
                await showMessageBox("Reanudando el contrato...", 'info', true);
                const tx = await stakingContract.unpause();
                await tx.wait();
                await showMessageBox(`Contrato reanudado. Hash de Tx: <a href="${BLOCK_EXPLORER_URL}/tx/${tx.hash}" target="_blank">${tx.hash.substring(0, 10)}...</a>`, 'success');
            } catch (error) {
                console.error("Error al reanudar contrato:", error);
                await showMessageBox(`Error al reanudar contrato: ${error.message}.`, 'error');
            } finally { hideMessageBox(); }
        });


        // --- Lógica de Pestañas (Tabs) ---
        function showTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.add('hidden');
            });
            document.getElementById(tabId).classList.remove('hidden');

            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            document.querySelector(`[id="${tabId.replace('Content', 'Tab')}"]`).classList.add('active');

            // Refresh data when switching to relevant tabs
            if (tabId === 'dashboardContent' && userAddress) {
                updateDashboardData();
                renderMyStakes();
            } else if (tabId === 'stakeContent' && userAddress) {
                renderStakingPools();
                updateDashboardData(); // To update available balance
            } else if (tabId === 'adminContent' && userAddress) {
                checkAdminAccess(); // Check admin access again on tab switch
            }
        }

        document.getElementById('dashboardTab').addEventListener('click', () => showTab('dashboardContent'));
        document.getElementById('stakeTab').addEventListener('click', () => showTab('stakeContent'));
        document.getElementById('withdrawTab').addEventListener('click', () => showTab('withdrawContent'));
        document.getElementById('adminTab').addEventListener('click', () => showTab('adminContent'));

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', async () => {
            // Check if MetaMask is already connected on page load
            if (window.ethereum && window.ethereum.selectedAddress) {
                await connectWallet(); // Attempt to auto-connect
            } else {
                updateWalletUI(); // Set UI to disconnected state
                // Show initial messages for each tab indicating to connect wallet
                document.getElementById('activeStakes').innerHTML = '<p class="text-gray-400">Conecta tu cartera para ver tus stakes.</p>';
                document.getElementById('stakingPool').innerHTML = '<option value="">Conecta tu cartera para ver los pools</option>';
                document.getElementById('adminMessage').classList.remove('hidden');
            }
            showTab('dashboardContent'); // Show dashboard by default
        });

        // Event listener for connect/disconnect button
        document.getElementById('connectWalletBtn').addEventListener('click', async () => {
            if (userAddress) {
                await disconnectWallet();
            } else {
                await connectWallet();
            }
        });
    </script>
</body>
</html>
